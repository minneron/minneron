#+title: minneron

* requirements view (features/use cases)                                 :rq:
:PROPERTIES:
:TS: <2013-01-11 11:41AM>
:ID: q5gdnjf0kzf0
:END:
** TODO [3/6] general purpose traditional text editor
*** DONE [0/0] #ED001 bare bones text editor                        :ed001:
:PROPERTIES:
:TS: <2013-01-03 01:38PM>
:ID: e526zw719zf0
:END:
*** DONE [4/6] #ED002 break / join lines in editor                  :ed002:
:PROPERTIES:
:TS: <2013-01-03 01:40PM>
:ID: 3kd48z719zf0
:END:
**** DONE break
:PROPERTIES:
:TS: <2013-01-07 01:46PM>
:ID: fccivi70fzf0
:END:

Breaking lines simply means that when the enter key is pressed:

  - everything to the right of the cursor is moved to a new string-node
  - the new string node is inserted inline in the buffer

**** DONE update cursors after break (editor.position and led.cpos)
:PROPERTIES:
:TS: <2013-01-07 05:49PM>
:ID: yux1esi0fzf0
:END:

**** DONE join lines when deleting newline
:PROPERTIES:
:TS: <2013-01-07 01:45PM>
:ID: eyzbcg70fzf0
:END:

**** DONE update cursor index after deleting (unecessary!)
:PROPERTIES:
:TS: <2013-01-07 05:49PM>
:ID: yux1esi0fzf0
:END:

Actually, when you delete the newline, the cursor stays in the same place.

**** TODO also join lines when backspacing through newline
:PROPERTIES:
:TS: <2013-01-07 11:54PM>
:ID: ouhg8oz0fzf0
:END:

This can wait.

**** TODO update /all/ attached cursors when inserting items into the list
:PROPERTIES:
:TS: <2013-01-07 06:42PM>
:ID: 8zt2b8l0fzf0
:END:
    { append this cursor to the array so we get notified of inserts/deletes }
    len := length( lis._cursors );
    setlength( lis._cursors, len + 1 );
    lis._cursors[ len ] := self;

test case:
    { when we insert, the cursors should update }
    ls.insert( a );
    chk.equal( ls.count, 3 );
    chk.that( cur.index = 3, 'cursor index didn''t update after insertion' );
    chk.equal( cur.index, 3 );

*** DONE [0/0] #ED003 save the updated file to disk                 :ed003:
:PROPERTIES:
:TS: <2013-01-03 01:40PM>
:ID: nfe6rz719zf0
:END:

*** TODO [0/0] #ED004 word wrap / virtual line mode                 :ed004:
:PROPERTIES:
:TS: <2013-01-03 01:41PM>
:ID: qr35d0819zf0
:END:

*** TODO [0/0] #ED005 regions (selections, highlights, etc)         :ed005:
:PROPERTIES:
:TS: <2013-01-03 01:41PM>
:ID: s36461819zf0
:END:
*** TODO [0/0] #ED006 cut, copy, paste                              :ed006:
:PROPERTIES:
:TS: <2013-01-03 01:42PM>
:ID: xdmg02819zf0
:END:
** TODO [0/4] outline support
:PROPERTIES:
:TS: <2013-01-11 12:15PM>
:ID: cg3654h0kzf0
:END:
*** TODO [0/0] #ED007 show/hide individual blocks
:PROPERTIES:
:TS: <2013-01-03 01:42PM>
:ID: r2n8o2819zf0
:END:
*** TODO [0/0] #ED008 move blocks inside the outline
:PROPERTIES:
:TS: <2013-01-03 01:42PM>
:ID: ug5a73819zf0
:END:
*** TODO [0/0] #ED009 styles for blocks
:PROPERTIES:
:TS: <2013-01-03 01:43PM>
:ID: lnl744819zf0
:END:
*** TODO [0/0] #ED010 tokenize/highlight within blocks
:PROPERTIES:
:TS: <2013-01-03 01:43PM>
:ID: cti3s4819zf0
:END:
** TODO [0/1] datagrid support
:PROPERTIES:
:TS: <2013-01-11 12:15PM>
:ID: bj8bk5h0kzf0
:END:
*** TODO [0/0] #ED011 tabular blocks                                :ed011:
:PROPERTIES:
:TS: <2013-01-03 01:44PM>
:ID: 0bbcs5819zf0
:END:
** TODO [0/3] literate programming support
:PROPERTIES:
:TS: <2013-01-11 12:16PM>
:ID: bx15a6h0kzf0
:END:
*** TODO [0/0] #ED012 tangle (generate source files)
:PROPERTIES:
:TS: <2013-01-03 01:44PM>
:ID: fx00t6819zf0
:END:
*** TODO [0/0] #ED013 weave (generate html site)
:PROPERTIES:
:TS: <2013-01-03 01:45PM>
:ID: l0e2c8819zf0
:END:
*** TODO [0/0] #ED014 trailblaze (weave + version control)
:PROPERTIES:
:TS: <2013-01-03 01:46PM>
:ID: wqf1y8819zf0
:END:
** TODO [0/0] task oriented, tiling window enviroment ( minneron )
:PROPERTIES:
:TS:       <2012-11-13 11:30AM>
:ID:       v735uzp0exf0
:END:
** TODO [0/0] multi-colum / table based editor
:PROPERTIES:
:TS:       <2012-11-10 11:27AM>
:ID:       0knej5s0axf0
:END:
** TODO [0/0] graph database ( port amoeba to pascal )
:PROPERTIES:
:TS:       <2012-11-13 11:26AM>
:ID:       bnyckup0exf0
:END:
** TODO [0/0] load/save minno
:PROPERTIES:
:TS:       <2012-11-10 11:46AM>
:ID:       det2o1t0axf0
:END:

** TODO [0/0] simple syntax highlighting / tokenization
:PROPERTIES:
:TS:       <2012-11-13 11:42AM>
:ID:       n7z7sjq0exf0
:END:
** TODO [0/0] a document command language                              :cmd:
:PROPERTIES:
:TS: <2013-01-10 07:42AM>
:ID: atnh8y21izf0
:END:
* package view (module outlines)                                         :pk:
:PROPERTIES:
:TS: <2013-01-11 09:40AM>
:ID: 7vwjky90kzf0
:END:
*** TODO MODULE =buf= -> rename to docs or texts
:PROPERTIES:
:TS: <2013-01-04 04:31AM>
:ID: u6chgny0azf0
:END:

#+begin_src pascal :tangle ".gen/buf.pas" :padline yes :noweb tangle
  {$i xpc.inc}
  unit buf;
  interface uses xpc, ll, li;
    <<type:token>>
    <<type:anchor>>
    <<type:buffer>>
    <<type:span>>
  implementation
  end.
#+end_src

*** MODULE =mn=                                                    :ed:ifc:
:PROPERTIES:
:TS: <2013-01-11 05:09AM>
:ID: fr5fryb1jzf0
:END:
#+begin_src pascal :tangle ".gen/mn.pas" :noweb tangle
  {$i xpc.inc}
  unit mn;
  interface uses ll, li, fs, stri, num, cw, crt, buf, ui, kbd, cli;
    <<type:editor>>
    <<type:span>>
  implementation
    <<@imp:ed>>
    <<@imp:span>>
  end.
#+end_src
*** PROGRAM =min=
:PROPERTIES:
:TS: <2013-01-12 06:30AM>
:ID: 34nd9ah0lzf0
:END:
#+begin_src pascal :tangle ".gen/min.pas" :noweb tangle
{ minneron
----------------------------------------------------------------
Copyright (c) 2012 Michal J Wallace. All rights reserved.
---------------------------------------------------------------}
{$i xpc.inc}
program min;
  uses mn, crt, cw;
  var ed : editor;
begin
  crt.clrscr;
  ed := editor.create;
  if paramcount = 0 then
    writeln( 'usage : min <filename>' )
  else if ed.load( paramstr( 1 )) then
  begin
    ed.run;
    ed.destroy;
    cw.cwriteln( '|w|!k' );
    crt.clrscr;
  end
  else writeln( 'unable to load file: ', paramstr( 1 ));
end.
#+end_src
* structural view (interface declaraions)                                :st:
:PROPERTIES:
:TS: <2013-01-11 11:21AM>
:ID: 02li6ne0kzf0
:END:
** TODO ngaro virtual machine <done but need defs here>                 :vm:
:PROPERTIES:
:TS: <2013-01-11 03:35AM>
:ID: la310m71jzf0
:END:
** [1/3] document model (spanning tree into the graph)                  :doc:
:PROPERTIES:
:TS: <2013-01-03 04:13PM>
:ID: v971ih00azf0
:END:
*** TYPE buffer
:PROPERTIES:
:TS: <2013-01-04 02:51AM>
:ID: o6e3l1u0azf0
:END:

The buffer is a simple, linear list of tokens, where tokens are either strings, or invisible markers pointing to document nodes.

#+name: type:buffer
#+begin_src pascal
  type buffer = class( specialize ll.list <token> )
  end;
#+end_src

*** TYPE token
:PROPERTIES:
:TS: <2013-01-12 06:41AM>
:ID: x4i08sh0lzf0
:END:

#+name: type:token
#+begin_src pascal
  type token = li.strnode;
#+end_src

Just plain old string nodes for now.

*** TYPE anchor                                                    :unused:
:PROPERTIES:
:TS: <2013-01-04 02:09AM>
:ID: 2mxaf3s0azf0
:END:

#+name: type:anchor
#+begin_src pascal
  type anchor = li.objnode;
#+end_src

Anchors are non-textual, and may hold any kind of data. They correspond roughly to <A> tags in html.

Unlike the generic list cursors, which are pointers to link objects in the linked list, anchors are data objects that are actually part of the buffer. This is so programs that traverse the list are able to see and make use of them.

*** TYPE element
:PROPERTIES:
:TS: <2013-01-12 03:20PM>
:ID: 8br01s51lzf0
:END:

#+name: type:element
#+begin_src pascal
  type element = li.lisnode;
#+end_src

*** TODO blocks
:PROPERTIES:
:TS: <2013-01-03 03:53PM>
:ID: s5pjy4e19zf0
:END:

Blocks are spans that act like xml elements, in that they are nestable but non-overlapping, and that each node in the tree contains references to its siblings, children, and a single parent node.

Aside from these fields, blocks can be of any type, and may or may not conform to any particular schema.

Most likely they would be implemented as =type generic block<t>=.

These can be used to indicate parsed structures such as lines of text, tokens (for syntax highlighting), etc.

*** DONE TYPE span
:PROPERTIES:
:TS: <2013-01-03 03:57PM>
:ID: f4x29ce19zf0
:END:
#+name: type:span
#+begin_src pascal
  { used for selections }
  type generic span<t> = class
  public
    type tag = class( anchor )
      is_start, is_end : boolean;
      span             : specialize span<t>;
    end;
  public
    start_tag, end_tag : tag;
    obj : t;
  end;
#+end_src

*** TODO other embedded objects
:PROPERTIES:
:TS: <2013-01-03 04:06PM>
:ID: nrrkq600azf0
:END:

Arbitrary objects can be embedded in the text. These may contain "clones" of text elsewhere in the document (or in another document, or calculated on the fly).

They are expected to display themselves, just like textual nodes.

** TODO user interface                                                  :ui:
:PROPERTIES:
:TS: <2013-01-11 11:07AM>
:ID: lb6auzd0kzf0
:END:
*** TODO line editor
:PROPERTIES:
:TS: <2013-01-11 11:22AM>
:ID: 2cxcdoe0kzf0
:END:

*** DONE editor type                                                   :ed:
:PROPERTIES:
:TS: <2013-01-11 11:09AM>
:ID: zy54y2e0kzf0
:END:
#+name: type:editor
#+begin_src pascal
  type editor = class
    buf               : buf.buffer;
    filename          : string;
    message           : string;
    x, y, h, w        : integer;
    topline, position : buf.buffer.cursor;
    led               : ui.zinput;  // led = Line EDitor
    constructor create;
    function load( path : string ) : boolean;
    function save_as( path : string ) : boolean;
    function save : boolean;
    procedure show;
    procedure run;

   protected { cursor movement commands }
    procedure arrowup;
    procedure arrowdown;
    procedure home;
    procedure _end;
    procedure pageup;
    procedure pagedown;

   protected { line manipulation commands }
    procedure newline;
    procedure delete;
  end;
#+end_src

** TODO database                                                        :mr:
:PROPERTIES:
:TS: <2013-01-11 11:21AM>
:ID: ae267me0kzf0
:END:
* procedural view (current procedure/method definitions)                 :pr:
:PROPERTIES:
:TS: <2013-01-11 11:07AM>
:ID: v0ufazd0kzf0
:END:
** DONE editor routines                                                 :ed:
:PROPERTIES:
:TS: <2013-01-11 08:46AM>
:ID: sghf0g70kzf0
:END:
*** class methods
:PROPERTIES:
:TS: <2013-01-12 07:37AM>
:ID: 7hd3ldk0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  constructor editor.create;
  begin
    inherited;
    x := 1;
    y := 1;
    w := crt.windMaxX;
    h := crt.windMaxY;
    self.buf := buffer.create;
    topline := self.buf.make_cursor;
    position := self.buf.make_cursor;
    filename := '';
    message  := 'welcome to minneron.';
  end;
#+end_src

*** disk interface
:PROPERTIES:
:TS: <2013-01-12 07:38AM>
:ID: f41aqek0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  function editor.load( path : string ) : boolean;
    var txt : text; line : string;
  begin
    result := fs.exists( path );
    if result then begin
      //  need to check for io errors in here
      assign( txt, path );
      reset( txt );
      while not eof( txt ) do begin
        readln( txt, line );
        self.buf.append( <<ed.load:line->node>> );
      end;
      close( txt );
      self.filename := path;
    end;
  end; { editor.load }

  function editor.save : boolean;
    var txt: text; node : li.node;
  begin
    assign( txt, self.filename );
    rewrite( txt );
    for node in self.buf do begin
      if node.kind = KSTR then writeln( txt, (node as strnode).str );
    end;
    close( txt );
    result := true; // TODO error checking
    message := filename + ' saved.';
  end;

  function editor.save_as( path : string ) : boolean;
    var oldname : string;
  begin
    oldname := self.filename;
    self.filename := path;
    result := self.save;
    if not result then self.filename := oldname
  end;
#+end_src

*** display interface
:PROPERTIES:
:TS: <2013-01-12 07:39AM>
:ID: 1oyksgk0lzf0
:END:
**** editor.show
:PROPERTIES:
:TS: <2013-01-13 04:33AM>
:ID: l0l8ixr0mzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  procedure editor.show;
    var
      ypos : cardinal;
      cur  : buffer.cursor;
      line : string = '';
    <<ed/show/curpos>>
    <<ed/show/nums>>
    <<ed/show/edit>>
    <<ed/show/line>>
  begin
    <<ed/show:main>>
  end;
#+end_src
**** «ed/show:main»
:PROPERTIES:
:TS: <2013-01-13 04:40AM>
:ID: 9u9baas0mzf0
:END:
#+name: ed/show:main
#+begin_src pascal
  begin
    // clrscr; //  fillbox( 1, 1, crt.windmaxx, crt.windmaxy, $0F20 );
    show_curpos;
    ypos := 2;
    cur := self.buf.make_cursor;
    cur.move_to( self.topline );
    repeat
      if cur.value.inheritsfrom( li.strnode ) then
      begin
        show_nums;
        line := li.strnode( cur.value ).str;
        if cur.index = position.index then show_edit( line )
        else show_line( line );
      end;
      inc( ypos )
    until ( ypos = self.h ) or ( not cur.move_next );
    while ypos < self.h do begin
      cwritexy( 1, ypos, '|%' );
      inc( ypos )
    end;
    led.show
  end;
#+end_src
**** «ed/show/curpos»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: j4k6vzr0mzf0
:END:
#+name: ed/show/curpos
#+begin_src pascal
  procedure show_curpos;
  begin
    cwritexy( 1, 1,
              '|B[|C' + flushrt( n2s( self.position.index ), 6, '.' ) +
              '|w/|c' + flushrt( n2s( self.buf.count ), 6, '.' ) +
              '|B] |G' + self.message +
           '|%' );
    self.message := '';
  end;
#+end_src
**** «ed/show/nums»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: dfe840s0mzf0
:END:
#+name: ed/show/nums
#+begin_src pascal
  procedure show_nums;
  begin
    cwritexy( 1, ypos, '|k|!c' );
    write( flushrt( n2s( cur.index ), 3, ' ' ));
    cwrite( '|!k|w' );
  end;
#+end_src
**** «ed/show/edit»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: de5ca0s0mzf0
:END:
#+name: ed/show/edit
#+begin_src pascal
  procedure show_edit( line : string );
  begin
    { This simply positions the input widget. }
    with self.led do begin
      x := crt.wherex;
      y := crt.wherey;
      tcol := $0E; // bright yellow
      dlen := crt.windmaxx - crt.wherex;
    end;
    // debug: clear to eol w/blue bg to show where control should be
    // cwrite( '|!b|%' );
    led.show;
  end;
#+end_src
**** «ed/show/line»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: 8lf6f0s0mzf0
:END:
#+name: ed/show/line
#+begin_src pascal
  procedure show_line( line : string );
  begin
    cwrite( stri.trunc( line, cw.scr.w - cw.cur.x ));
    cwrite( '|%' ); // clreol
  end;
#+end_src

*** cursor movement interface
:PROPERTIES:
:TS: <2013-01-12 07:41AM>
:ID: 34ca2jk0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal

  procedure editor.home;
  begin
    if self.buf.first = nil then exit;
    position.to_top;
    topline.to_top;
    if position.value.inheritsfrom( li.strnode ) then
      led.work := li.strnode( position.value ).str
    else
      led.work := '<<marker>>';
  end;

  procedure editor._end;
    var i : byte;
  begin
    self.position.to_end;
    self.topline.to_end;
    for i := crt.windmaxy div 2 downto 1 do
      self.topline.move_prev;
  end;

  procedure editor.pageup;
    var c : byte;
  begin for c := 1 to h do arrowup;
  end;

  procedure editor.pagedown;
    var c : byte;
  begin for c := 1 to h do arrowdown;
  end; { editor.pagedown }
#+end_src

#+name: @imp:ed
#+begin_src pascal
  procedure editor.arrowup;
  begin
    li.strnode(self.position.value).str := led.value;
    if self.position.move_prev then
    begin
      if self.position.index - self.topline.index < 5 then
          if self.topline.index > 1 then
             self.topline.move_prev;
      //  scrolldown1(1,80,y1,y2,nil);
      //  scrolldown1(1,80,14,25,nil);
    end
    else self.position.move_next;
    led.work := li.strnode(self.position.value).str;
  end;

  procedure editor.arrowdown;
    var screenline : word;
  begin
    li.strnode(self.position.value).str := led.value;
    if self.position.move_next then
      begin
        assert( self.topline.index <= self.position.index );
        screenline := self.position.index - self.topline.index;
        if ( screenline > self.h - 5 ) and ( self.topline.index < self.buf.count ) then
           self.topline.move_next
          //  scrollup1(1,80,y1,y2,nil);
          //  scrollup1(1,80,14,25,nil);
      end
    else self.position.to_end;
    led.work := li.strnode(self.position.value).str;
  end;
#+end_src

*** modal interface
:PROPERTIES:
:TS: <2013-01-12 07:41AM>
:ID: lxfhwjk0lzf0
:END:

#+name: @imp:ed
#+begin_src pascal
  procedure editor.run;
    var done : boolean = false; ch : char;
  begin
    self.led := ui.zinput.create;
    self.home;
      repeat
      show;
      case kbd.readkey(ch) of
        ^C : done := true;
        ^N : arrowdown;
        ^P : arrowup;
        ^M : newline;
        ^D : delete;
        ^S : save;
        ^V : pagedown;
        ^U : pageup;
        #0 : case kbd.readkey(ch) of
                    #72 : arrowup; // when you press the UP arrow!
                    #80 : arrowdown; // when you press the DOWN arrow!
                    #71 : home;
                    #79 : _end;
                    #73 : pageup;
                    #81 : pagedown;
                    else led.handlestripped( ch ); led.show;
                  end;
        else led.handle( ch ); led.show;
      end
    until done;
  end;
#+end_src

*** multi-line editor commands
:PROPERTIES:
:TS: <2013-01-12 07:42AM>
:ID: pn7bmlk0lzf0
:END:

#+name: @imp:ed
#+begin_src pascal
  procedure editor.newline;
  begin
    position.inject_next( strnode.create( led.str_to_end ));
    led.del_to_end;
    arrowdown;
    led.to_start
  end; { editor.newline }

  procedure editor.delete;
    var cur : buffer.cursor;
  begin
    if led.at_end then begin
      if not position.at_end then begin
        cur := buf.make_cursor;
        cur.move_to(position);
        cur.move_next;
        led.work += li.strnode( cur.value ).str;
        position.delete_next;
        cur.free;
      end
    end
    else led.del
  end;
#+end_src
** TODO «tokenizer»                                                    :tok:
:PROPERTIES:
:TS: <2013-01-11 05:05AM>
:ID: er586tb1jzf0
:END:
#+name: ed.load:line->node
#+begin_src pascal
token.create( line )
#+end_src
* planning view (implementation plans for new features)                  :pl:
:PROPERTIES:
:TS: <2013-01-11 11:43AM>
:ID: l6i37of0kzf0
:END:
** TODO [1/4] word wrap implementation                                :ed004:
:PROPERTIES:
:TS: <2013-01-11 11:45AM>
:ID: hnyjxqf0kzf0
:END:
*** TODO break input lines down into tokens
:PROPERTIES:
:TS: <2013-01-11 03:17AM>
:ID: cpvbjt61jzf0
:END:
*** TODO add an offset to the cursor type
:PROPERTIES:
:TS: <2013-01-10 09:37AM>
:ID: uzh4ta81izf0
:END:

*** TODO generate display blocks from the line spans
:PROPERTIES:
:TS: <2013-01-10 09:38AM>
:ID: xzn4eb81izf0
:END:
elements are sequences/strings with a 1-dimensional length
blocks are rectangles with a 2-dimensional bounding box
** TODO [0/2] block-based display plan                               :ed007:
:PROPERTIES:
:TS: <2013-01-01 10:35PM>
:ID: tm74ek017zf0
:END:
*** TODO displaying documents                                          :ui:
:PROPERTIES:
:TS: <2013-01-03 04:13PM>
:ID: qbighi00azf0
:END:
**** straightforward linear flow display
:PROPERTIES:
:TS: <2013-01-04 04:30AM>
:ID: yb55yly0azf0
:END:

**** the scene graph                                               :later:
:PROPERTIES:
:TS: <2013-01-03 04:16PM>
:ID: iza8lm00azf0
:END:

The block objects serve a secondary purpose, in that they can recursively display themselves (just like widgets in gamesketchlib or whatever).

However, document structure and display structure needn't coincide: nodes might be hidden, or show up at arbitrary coordinates, etc.

So it's likely that each node would have a corresponding display object, which understood coordinates, geometry, etc.

In particular, two clones of the same node would have different geometries and coordinates.

Note also that display nodes may not be textual: raster images, vector shapes,
and dialog widgets are all perfectly valid options.
*** TODO SECTION crawler concept (cursor+stack machine)               :cur:
:PROPERTIES:
:TS: <2013-01-10 07:43AM>
:ID: vfbhc031izf0
:END:
**** TODO add clasp as an actual node type, with left,right, and up pointers. :ll:
:PROPERTIES:
:TS: <2013-01-10 08:17AM>
:ID: 9s66sl41izf0
:END:
**** TODO add hook as a node type with left, right, and down pointers. :ll:
:PROPERTIES:
:TS: <2013-01-10 08:19AM>
:ID: rq33yn41izf0
:END:
*** TODO make a stack for offsets, so the document can be a tree
:PROPERTIES:
:TS: <2013-01-10 09:43AM>
:ID: r2bl0k81izf0
:END:
*** TODO introduce the block type (nested span)
:PROPERTIES:
:TS: <2013-01-12 02:50PM>
:ID: 3xyfre41lzf0
:END:
*** TODO break the input text into tokens grouped by element nodes
:PROPERTIES:
:TS: <2013-01-10 09:37AM>
:ID: uwf83b81izf0
:END:
** TODO [0/2] command interpreter plan                                 :cmd:
:PROPERTIES:
:TS: <2013-01-01 10:35PM>
:ID: 6v09mj017zf0
:END:
*** TODO number-based dispatch
:PROPERTIES:
:TS: <2013-01-10 07:47AM>
:ID: va99k631izf0
:END:
*** TODO string-based dispatch
:PROPERTIES:
:TS: <2013-01-10 07:46AM>
:ID: if8k2631izf0
:END:
** TODO [0/0] table editor implementation                            :ed011:
:PROPERTIES:
:TS:       <2012-11-10 02:30PM>
:ID:       uhv4ml01axf0
:END:
*** load arrays of nodes
:PROPERTIES:
:TS: <2013-01-11 12:01PM>
:ID: nhqb8ig0kzf0
:END:
*** TODO [0/0] merge in file:~/r/work/griddemo.pas
:PROPERTIES:
:TS:       <2012-11-13 10:48AM>
:ID:       re6c12o0exf0
:END:
** TODO [0/0] database implementation
:PROPERTIES:
:TS: <2013-01-11 12:01PM>
:ID: xob8dhg0kzf0
:END:
* narrative view (completed plans/notes, old versions, etc)              :nr:
:PROPERTIES:
:TS: <2013-01-12 07:58AM>
:ID: qxoi0cl0lzf0
:END:
** TODO [0/4] prerequisites
:PROPERTIES:
:TS: <2013-01-11 04:49AM>
:ID: 21j3a1b1jzf0
:END:
*** TODO SECT What you should already know.
:PROPERTIES:
:TS: <2013-01-11 04:53AM>
:ID: 0zjgg8b1jzf0
:END:
*** TODO link to introductory pascal
:PROPERTIES:
:TS: <2013-01-11 04:53AM>
:ID: u7x539b1jzf0
:END:
*** TODO show the cursor interface
:PROPERTIES:
:TS: <2013-01-11 04:49AM>
:ID: r0oel1b1jzf0
:END:
*** TODO ui.input interface
:PROPERTIES:
:TS: <2013-01-11 04:50AM>
:ID: olz7x3b1jzf0
:END:
** DONE [6/6] implementing basic editor                              :ed001:
:PROPERTIES:
:TS: <2013-01-11 12:09PM>
:ID: k3n7vug0kzf0
:END:
*** DONE [3/3] CARD get cedit.pas working again
:PROPERTIES:
:TS:       <2012-11-10 12:42PM>
:ID:       hcg7aat0axf0
:END:
**** DONE pntstuff.pas(66,15) Error: Wrong number of parameters specified for call to "killnode" :bug:
:PROPERTIES:
:TS:       <2012-11-10 12:54PM>
:ID:       st87v6w0axf0
:END:
This just needed an @ to prevent invocation.

**** DONE crtstuff.pas(1472,4) Fatal: Selected assembler reader not supported :bug:
:PROPERTIES:
:TS:       <2012-11-10 01:09PM>
:ID:       uq04zvw0axf0
:END:
***** NOTE basically, crtstuff doesn't compile.
:PROPERTIES:
:TS:       <2012-11-10 01:36PM>
:ID:       65f0e4y0axf0
:END:
***** NOTE workaround: use cw instead ( ?? )
:PROPERTIES:
:TS:       <2012-11-10 01:40PM>
:ID:       dlvgsay0axf0
:END:
***** NOTE . or: just describe the program from the top down
:PROPERTIES:
:TS:       <2012-11-10 01:51PM>
:ID:       qbkefty0axf0
:END:
Maybe rather than trying to compile it, with all those huge broken dependencies, I should just start at the begin section and try and clean it up.
***** NOTE . decided to do both.
:PROPERTIES:
:TS:       <2012-11-10 03:09PM>
:ID:       8k7jrf21axf0
:END:
I commented out most of cedit (anything that relied on my old code, especially). Now I'm going to step through and clean it up a little at a time, making sure it compiles.
***** NOTE . refactoring, test framework, etc
:PROPERTIES:
:TS:       <2012-11-12 01:32PM>
:ID:       ola4zkf0dxf0
:END:
Well, I got cedit to compile at some point in the past few days. I basically commented everything out that wasn't pure pascal, and then re-enabled one line at a time until it compiled. Along the way, I broke crtstuff down into smaller pieces.

Unfortunately, it still doesn't work, so last night I started making a test framework. Actually, I /tried/ to use dunit, but I couldn't get it to compile... And then I decided it was just way bigger and complicated than I really needed anyway. Yes, the gestalt problem again.

Anyway, I wrote my own little test system last night, so today I will track down the bugs in the linked list module by implementing some tests to specify how this thing is supposed to work.

**** DONE cedit shows no text, crashes on arrowdown                  :bug:
:PROPERTIES:
:TS:       <2012-11-12 01:48PM>
:ID:       98dh8bg0dxf0
:END:
***** NOTE repaired ll.append/insert logic, then moved from objects->classes
:PROPERTIES:
:TS:       <2012-11-13 03:25AM>
:ID:       pmcf1l30exf0
:END:
I think probably the code worked before, but I somehow broke things while trying to get it to compile at all. In any case, I now have a test framework cleared out a /bunch/ of duplicate logic from this thing.

Still have one bug, but it's in ~cw.pas~, not ~cedit~, so I'm going to mark this done! :)
*** DONE [0/0] create a simple line editor ( ui.zinput as reference? )
:PROPERTIES:
:TS:       <2012-11-10 02:37PM>
:ID:       fr78ey01axf0
:END:
*** DONE [2/2] build oberon-style "text" (ll of strings + markers)
:PROPERTIES:
:TS:       <2012-11-13 11:53AM>
:ID:       w4q793r0exf0
:END:
**** DONE [0/0] create a token type
:PROPERTIES:
:TS: <2013-01-01 10:45PM>
:ID: ez8ho0117zf0
:END:
[0104.2013 04:54AM] done in type token (really same as li.strtoken)

**** DONE [0/0] create linked list of tokens
:PROPERTIES:
:TS: <2013-01-01 10:47PM>
:ID: 06kgs4117zf0
:END:
[0104.2013 04:55AM] done in type tagtoken = li.objtoken

*** DONE [0/0] convert cedit to use the buffer type
:PROPERTIES:
:TS: <2013-01-04 04:56AM>
:ID: f7a9vtz0azf0
:END:

I suppose in this case, we want to use elements/blocks.

Looks like it's already using stringnodes, but that's pretty much the same as li.strnode, so i might as well use a list of li.nodes. But I'll go ahead and use the buffer type I created in mn.trail.

Another thing I did was make the editor class (previously =listeditor=) be a container for a buffer, rather than a subclass.

*** DONE [0/0] read lines of text as the initial chunks
:PROPERTIES:
:TS: <2013-01-01 10:46PM>
:ID: kozjs1117zf0
:END:

This was already done in cedit too. :)

*** DONE [0/0] show the line editor on the highlighted line
:PROPERTIES:
:TS: <2013-01-04 07:15AM>
:ID: th42v961azf0
:END:
** CARD working through wordwrap / tokenization                      :ed004:
:PROPERTIES:
:TS: <2013-01-11 03:17AM>
:ID: f0042s61jzf0
:END:
*** NOTE still stuck on wordwrap
:PROPERTIES:
:TS: <2013-01-11 02:15AM>
:ID: v6zgxw31jzf0
:END:
I'm still stuck. I know that word wrap is my next step, but I'm not sure what to do yet.
Does zinput need to change?

Suppose I leave zinput alone as a simple string editor, and I just use it to edit one token at a time. Every time I hit space or enter, I move the editor widget. This is nice, because it means I don't have to change zinput.

It does mean I need to break the file into tokens. Right now, I'm using pascal's standard =ReadLn= function, which simply reads characters until it encounters a platform-specific newline marker.
*** NOTE spans should not be the superclass for elements
:PROPERTIES:
:TS: <2013-01-12 02:49PM>
:ID: jd1crc41lzf0
:END:

For a while, I thought it made sense to have a strictly linear text buffer, where each block was marked by two separate anchors. The idea was that cursor movement would then always be either an array offset change, or it would be a pointer change.

I think this was simply me over-applying the jumptree metaphor and picturing a rim - a single, linear list of tokens.

But this data structure is un-necessary. Instead of two anchor nodes, I can just use a single element node.

* TODO <cleanup> support view (meta / tool stuff)                        :su:
:PROPERTIES:
:TS: <2013-01-11 11:08AM>
:ID: okc3d1e0kzf0
:END:
** TODO behavior driven test harness
:PROPERTIES:
:TS: <2013-01-11 03:40AM>
:ID: ogu9pv71jzf0
:END:
#+begin_src pascal :tangle ".gen/test_edcmds.pas" :padline yes :noweb tangle
  program test_edcmds;
  uses min;
    var
      ch       : char;
      ed       : min.editor;
      expected : string;
      passed,
      failed   : cardinal;

    <<runln>>
    <<testln>>
    <<report>>
  begin
    ed.create;
    while not eof do
      case read( ch ) of
        '$' : readln( ed.value );
        '>' : runln;
        '!' : testln;
      end
    <<report>>
  end.
#+end_src
** TODO [0/0] implement org-babel-tangle
:PROPERTIES:
:TS:       <2012-11-13 11:06AM>
:ID:       ls96dwo0exf0
:END:
** TODO [1/2] get all my <old> pascal code into a database
:PROPERTIES:
:TS:       <2012-11-10 12:42PM>
:ID:       k1b2zlv0axf0
:END:
maybe use the code tools?
*** DONE convert old pascal source files to unicode
:PROPERTIES:
:TS:       <2012-11-10 02:21PM>
:ID:       gs594801axf0
:END:
*** TODO parse pascal/oberon/turbo                                 :parser:
:PROPERTIES:
:TS:       <2012-11-10 01:50PM>
:ID:       yv64pry0axf0
:END:
** TODO [0/0] cw.cwriteln's end of line handling breaks ( on linux, anyway ). :bug:
:PROPERTIES:
:TS:       <2012-11-13 03:29AM>
:ID:       mmherr30exf0
:END:
This could be compounded by the fact that I'm also trying to use kvm.
** TODO [0/0] [#A] parse org files - see file:~/r/@code/@py/o2x.py
:PROPERTIES:
:TS:       <2012-11-10 11:18AM>
:ID:       d0c5kpr0axf0
:END:
* TODO <cleanup> INBOX unfiled items - clarify!                          :xx:
:PROPERTIES:
:TS: <2013-01-11 11:48AM>
:ID: m4p4mvf0kzf0
:END:
** TODO console web browsers
:PROPERTIES:
:TS: <2013-01-11 11:48AM>
:ID: 91khtvf0kzf0
:END:
** TODO [0/0] get tmux to work sort of like autohotkey                :tmux:
:PROPERTIES:
:TS:       <2012-11-10 11:18AM>
:ID:       mpj2aqr0axf0
:END:
** TODO [0/1] database forms
:PROPERTIES:
:TS:       <2012-11-13 11:48AM>
:ID:       eso31uq0exf0
:END:
*** TODO [0/0] I think ymenu has a basic form. I could mix with html/django form model
:PROPERTIES:
:TS:       <2012-11-13 11:48AM>
:ID:       xov0muq0exf0
:END:
** TODO [0/2] harvest other editors ( once I have core editor working in pascal )
:PROPERTIES:
:TS:       <2012-11-13 11:42AM>
:ID:       kt1h6kq0exf0
:END:
*** TODO [0/0] harvest diakonos
:PROPERTIES:
:TS:       <2012-11-13 11:40AM>
:ID:       5g1jugq0exf0
:END:
*** TODO [0/0] harvest codemirror
:PROPERTIES:
:TS:       <2012-11-13 11:42AM>
:ID:       ccr0wkq0exf0
:END:
** WANT browser keybidings for scroll, etc                         :browser:
:PROPERTIES:
:TS:       <2012-11-10 11:20AM>
:ID:       kjx0ctr0axf0
:END:
i wish i could use my normal keybindings for paging, etc in the browser
*** TODO try conkeror
:PROPERTIES:
:TS:       <2012-11-10 11:21AM>
:ID:       4dmjvur0axf0
:END:
** TODO command reference                                              :cmd:
:PROPERTIES:
:TS: <2013-01-10 08:24AM>
:ID: rfxenx41izf0
:END:
*** cursor movement commands
:PROPERTIES:
:TS: <2013-01-10 08:24AM>
:ID: zm4gsw41izf0
:END:
*** tree movement commands
:PROPERTIES:
:TS: <2013-01-10 08:31AM>
:ID: 8ybhm851izf0
:END:
*** version control commands
:PROPERTIES:
:TS: <2013-01-10 08:32AM>
:ID: wekjl951izf0
:END:
**** undo/redo
:PROPERTIES:
:TS: <2013-01-10 08:32AM>
:ID: 7y602a51izf0
:END:

*** string manipulation commands
:PROPERTIES:
:TS: <2013-01-10 08:24AM>
:ID: 8p551x41izf0
:END:
**** TODO insert char
:PROPERTIES:
:TS: <2013-01-10 08:25AM>
:ID: xq7dbz41izf0
:END:
**** TODO delete char
:PROPERTIES:
:TS: <2013-01-10 08:26AM>
:ID: zctajz41izf0
:END:

*** compiler commands
:PROPERTIES:
:TS: <2013-01-10 08:25AM>
:ID: yb66dy41izf0
:END:

*** range/selection commands
:PROPERTIES:
:TS: <2013-01-10 08:29AM>
:ID: 0izal551izf0
:END:

*** token/highlight commands
:PROPERTIES:
:TS: <2013-01-10 08:29AM>
:ID: 9o44r451izf0
:END:
**** set style
:PROPERTIES:
:TS: <2013-01-10 08:29AM>
:ID: c83lc551izf0
:END:
**** break token (space bar)
:PROPERTIES:
:TS: <2013-01-10 08:52AM>
:ID: ps0ca761izf0
:END:

*** terminal commands
:PROPERTIES:
:TS: <2013-01-10 08:28AM>
:ID: jntap351izf0
:END:
**** cursor position
:PROPERTIES:
:TS: <2013-01-10 08:28AM>
:ID: x4h40451izf0
:END:
**** set color
:PROPERTIES:
:TS: <2013-01-10 08:28AM>
:ID: b0067451izf0
:END:
** TODO graphical tmux-like thing for windows ( but with browsers, etc ) :unclear:
:PROPERTIES:
:TS:       <2012-11-10 11:18AM>
:ID:       23q5upr0axf0
:END:
Could use windows API, or mozilla.
** i want to unify the emacs and tmux keybindngs                      :tmux:
:PROPERTIES:
:TS:       <2012-11-10 11:18AM>
:ID:       5yfj6qr0axf0
:END:
especially for switching / resizing windows
C-x | to do vertical split, maybe?
** TODO [0/0] load entire files directly into ram
:PROPERTIES:
:TS:       <2012-11-10 12:21PM>
:ID:       hpwbsmu0axf0
:END:
Rather than deal with the bytestream protocol, just load the files directly into ram, and deal with them there. This gives us random access, etc.
** IDEA li.node -> atom/cell
:PROPERTIES:
:TS: <2013-01-12 03:32PM>
:ID: s8i3gc61lzf0
:END:

First, li is the wrong name for the unit, because it's not actually an interpreter, just a hand-built scanner / parser.

Second, it kind of makes sense to use node for items in the document / tree / graph structure. An html tag is something like a nested record after all.

A better name for these things would be atom or cell, as in lisp.

** PLAN building primitive types up from registers
:PROPERTIES:
:TS: <2013-01-12 04:00PM>
:ID: 51dk9s61lzf0
:END:

1. cardinal -> computer cells as natural number
2. pointer  -> using cardinals to reference positions in ram
3. array    -> pointer + /relative/ pointer (length).
4. bitmap   -> so we can draw pixels to make our characters
5. char     -> so we can create a simple bitmap font

** PLAN an 8-bit character device
:PROPERTIES:
:TS: <2013-01-12 04:00PM>
:ID: 2455zm71lzf0
:END:
*** .
 A simple terminal program would probably fit in 256 bytes, so an 8-bit computer for a character generator isn't out of the question if we can store the character map in rom and refer to it with a single byte.

 The old text display at (* 80 25) is 2000 bytes, or 4000 if we add another byte for color. That wastes 96 bytes if video ram is 4k.

 Since 2000 or 4000 is more than a single register can handle at 8 bits, we have to use 2 of them to loop through video ram.

 This is actually a nice machine to use because with 8 bits, we only need an adder, and it'll just loop around after 256 instructions.

 What would be really cool is if we could introduce the instruction set along with this, and even show how we could build it out of circuits.

*** NOTE . uses for the 160 extendend characters (+ 128 32)
 :PROPERTIES:
 :TS: <2013-01-12 04:13PM>
 :ID: fi9g6981lzf0
 :END:

40 : shavian / quickscript
16 : hex numbers
16 : math: \ne \le \ge lam \pi \radic \sup2 in \not and or dot subset superset \div \times
12 : box drawing (4 corners, -, |, |- -|, +, T, upside down T)
 6 : chess pieces (1k 2q 3r 4b 5n 6p)
 4 : card suits (d c s h)
 4 : l,r,u,d arrows
 3 : walls ( 4/5 shade (same as 1/5), 3/5 shade, 2/5 shade )
 2 : chevrons
 2 : game: face, ghost
 2 : half blocks (vertical and horizontal)
 1 : type symbol \curren (currency)

(- 128 (+ 40 16 16 12 6 4 4 3 2 2 2 1 ))

20 left over for the user, but of course we will implement unicode later.

** PLAN building a type system for nodes (records/tuples/messages...)
:PROPERTIES:
:TS: <2013-01-12 04:54PM>
:ID: jqz9j5a1lzf0
:END:

*** STEP . array size as a type
:PROPERTIES:
:TS: <2013-01-12 04:58PM>
:ID: 5d2iqba1lzf0
:END:
Not in the old pascal sense, just "a thing that takes up x bytes."


*** STEP . create an array the size of RAM at address 0
:PROPERTIES:
:TS: <2013-01-12 05:17PM>
:ID: 8eqak7b1lzf0
:END:

*** STEP . pointer + size + array = string or dynamic array
:PROPERTIES:
:TS: <2013-01-12 05:06PM>
:ID: uw798qa1lzf0
:END:
pointer points to index 0. previous cell would hold the length.
*** STEP . tuple is a size-3 array of ( name, slotcount, array of coldefs )
:PROPERTIES:
:TS: <2013-01-12 04:56PM>
:ID: q6jik9a1lzf0
:END:
*** TODO STEP . coldef <already defined in file:minneron.vue>
:PROPERTIES:
:TS: <2013-01-12 05:13PM>
:ID: ahui21b1lzf0
:END:
*** STEP . define a procedure to allocate an amount of ram
:PROPERTIES:
:TS: <2013-01-12 05:18PM>
:ID: u5vc79b1lzf0
:END:



Here's an easy approach, assuming we can access individual bytes:

#+begin_src pascal
  function allocate( cells : cardinal ) : pointer;
  begin
    result := pointer( @ram + here );
    inc( vm.here, num_cells );
  end;
#+end_src

*** TODO decide between forth/pascal usages of '@'                  :wejal:
:PROPERTIES:
:TS: <2013-01-12 05:38PM>
:ID: ykygi7c1lzf0
:END:
pascal : address of.
forth  : dereference.

Pascal code really has no business using @.

** PLAN . build the code generator from the bottom up
:PROPERTIES:
:TS: <2013-01-12 05:56PM>
:ID: d7vcc1d1lzf0
:END:
*** TODO NOTE . implement addition from nand / not+and+xor
:PROPERTIES:
:TS: <2013-01-12 06:02PM>
:ID: kxoizad1lzf0
:END:

#+begin_src pascal
  
  carries := 0;
  repeat
    simple_add := a xor b;
    carries := a and b;
    carries := carries shl 1
  until carries = 0 or bits := 8;
  
#+end_src

**** DONE also figure out how to implement =shl= with those primitives
:PROPERTIES:
:TS: <2013-01-12 06:07PM>
:ID: 8nphxjd1lzf0
:END:

i can see how to do it with :
#+begin_src pascal
  { pascal has a 'shl' operator, but if it didn't,
    you could make it yourself from AND and OR }
  function shift_left_from_scratch( b : byte ) : byte;
    var s : byte;
  begin
    s := 0;
    if ( b and 128 ) <> 0 then s := s or 64;
    if ( b and  64 ) <> 0 then s := s or 32;
    if ( b and  32 ) <> 0 then s := s or 16;
    if ( b and  16 ) <> 0 then s := s or  8;
    if ( b and   8 ) <> 0 then s := s or  4;
    if ( b and   4 ) <> 0 then s := s or  2;
    if ( b and   2 ) <> 0 then s := s or  1;
    result := s
  end;
#+end_src


*** NOTE . branches ( forward jumps )
:PROPERTIES:
:TS: <2013-01-12 06:00PM>
:ID: uee4q7d1lzf0
:END:
Remember: do these first because we get loops for free from the overflow.

*** NOTE . loops ( backward jumps )
:PROPERTIES:
:TS: <2013-01-12 05:59PM>
:ID: x1k5l5d1lzf0
:END:

*** NOTE . invocation ( calling conventions )
:PROPERTIES:
:TS: <2013-01-12 06:00PM>
:ID: nu81r6d1lzf0
:END:

**** NOTE . procedure calls ( gosub )
:PROPERTIES:
:TS: <2013-01-12 05:59PM>
:ID: 1qb5r5d1lzf0
:END:

**** NOTE . procedure return
:PROPERTIES:
:TS: <2013-01-12 05:59PM>
:ID: x0mbv5d1lzf0
:END:

**** NOTE . 
:PROPERTIES:
:TS: <2013-01-12 06:01PM>
:ID: zus599d1lzf0
:END:


** PLAN . code generator + parse engine + oberon grammar = bottom up compiler
:PROPERTIES:
:TS: <2013-01-12 06:28PM>
:ID: yqxheie1lzf0
:END:
*** NOTE . keep the grammar LL(1) at this point (so no backtracking)
:PROPERTIES:
:TS: <2013-01-12 06:34PM>
:ID: igmhx600mzf0
:END:
*** NOTE . push values to a stack as they're matched. gen code immediately.
:PROPERTIES:
:TS: <2013-01-12 06:33PM>
:ID: iw2hn600mzf0
:END:

** PLAN . emit code to allow /both/ static and dynamic type checking
:PROPERTIES:
:TS: <2013-01-12 05:46PM>
:ID: 34kahkc1lzf0
:END:

compiler's type system can be re-used in the vm. 
the only difference is that the type checking code is inserted up front.

#+begin_src pascal
  procedure emit_procedure( p : proc_def );
  begin
    emit_dynamic_checks;
    p.static_start := here;
    emit_local_inits( p.local_defs );
    emit_proc_body( p.body );
    emit_return( p.has_result );
  end;
#+end_src

** PLAN building more scalar types
:PROPERTIES:
:TS: <2013-01-12 04:56PM>
:ID: wtkfp8a1lzf0
:END:
*** NOTE . introduce big integers
:PROPERTIES:
:TS: <2013-01-12 04:55PM>
:ID: z1o6j7a1lzf0
:END:
*** NOTE . introduce sets
:PROPERTIES:
:TS: <2013-01-12 04:55PM>
:ID: xtha87a1lzf0
:END:







* end.
