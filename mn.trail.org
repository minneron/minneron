#+title: minneron

* TODO behavior driven test harness
:PROPERTIES:
:TS: <2013-01-11 03:40AM>
:ID: ogu9pv71jzf0
:END:
#+begin_src pascal :tangle ".gen/test_edcmds.pas" :padline yes :noweb tangle
  program test_edcmds;
  uses min;
    var
      ch       : char;
      ed       : min.editor;
      expected : string;
      passed,  
      failed   : cardinal;
  
    <<runln>>
    <<testln>>
    <<report>>
  begin
    ed.create;
    while not eof do
      case read( ch ) of
        '$' : readln( ed.value );
        '>' : runln;
        '!' : testln;
      end
    <<report>>
  end.
#+end_src

* SECTION starting point
:PROPERTIES:
:TS: <2013-01-11 04:49AM>
:ID: 21j3a1b1jzf0
:END:
** TODO SECT What you should already know.
:PROPERTIES:
:TS: <2013-01-11 04:53AM>
:ID: 0zjgg8b1jzf0
:END:
** TODO link to introductory pascal
:PROPERTIES:
:TS: <2013-01-11 04:53AM>
:ID: u7x539b1jzf0
:END:
** TODO show the cursor interface
:PROPERTIES:
:TS: <2013-01-11 04:49AM>
:ID: r0oel1b1jzf0
:END:
** TODO ui.input interface
:PROPERTIES:
:TS: <2013-01-11 04:50AM>
:ID: olz7x3b1jzf0
:END:


* loading the file
:PROPERTIES:
:TS: <2013-01-11 04:55AM>
:ID: 6wgjjcb1jzf0
:END:
#+begin_src pascal
  function editor.load( path : string ) : boolean;
    var txt : text; line : string;
  begin
    if fs.exists( path ) then begin
      assign( input, path );
      reset( path );
      while not eof( input ) do begin
        readln( input, line );
        self.buf.append( <<make-line-node>> )
      end;
      close( input );
      self.filename := path
    end
  end;
#+end_src

* 
:PROPERTIES:
:TS: <2013-01-11 05:05AM>
:ID: er586tb1jzf0
:END:

stringtoken.create( line )



* SECTION documents (spanning tree into the graph)
:PROPERTIES:
:TS: <2013-01-03 04:13PM>
:ID: v971ih00azf0
:END:
** buffers
:PROPERTIES:
:TS: <2013-01-03 03:29PM>
:ID: jek9h1d19zf0
:END:
*** TYPE buffer
:PROPERTIES:
:TS: <2013-01-04 02:51AM>
:ID: o6e3l1u0azf0
:END:

The buffer is a simple, linear list of tokens, where tokens are either strings, or invisible markers pointing to document nodes.

#+name: type:buffer
#+begin_src pascal
  type buffer = class( specialize ll.list <token> )
  end;
#+end_src

*** TYPE Token
:PROPERTIES:
:TS: <2013-01-04 02:09AM>
:ID: 2mxaf3s0azf0
:END:

#+name: @type:token
#+begin_src pascal
  type token = li.node;
#+end_src

*** TYPE StringToken
:PROPERTIES:
:TS: <2013-01-04 02:08AM>
:ID: kaujt1s0azf0
:END:

#+name: @type:token
#+begin_src pascal
  type stringtoken = li.strnode;
#+end_src

*** TYPE TagToken
:PROPERTIES:
:TS: <2013-01-03 03:29PM>
:ID: d28jz1d19zf0
:END:

#+name: @type:token
#+begin_src pascal
  type tagtoken = li.objnode;
#+end_src

Tag tokens are non-textual, and may hold any kind of data.

Unlike the generic list cursors, which are pointers to link objects in the linked list, markers are data objects that are actually part of the buffer. This is so programs that traverse the list are able to see the markers.

** spans
:PROPERTIES:
:TS: <2013-01-03 03:57PM>
:ID: f4x29ce19zf0
:END:

Span is a generic type, suitable for use with nested elements but also for arbitrary regions like selected text.

#+name: @types
#+begin_src pascal
  type
    generic span<t> = class
    public
      type tag = class( tagtoken )
        is_start, is_end : boolean;
        span             : specialize span<t>;
      end;
      start_tag, end_tag : tag;
      obj : t;
    end;
#+end_src

** blocks
:PROPERTIES:
:TS: <2013-01-03 03:53PM>
:ID: s5pjy4e19zf0
:END:

Blocks are spans that act like xml elements, in that they are nestable but non-overlapping, and that each node in the tree contains references to its siblings, children, and a single parent node.

Aside from these fields, blocks can be of any type, and may or may not conform to any particular schema.

Most likely they would be implemented as =type generic block<t>=.

These can be used to indicate parsed structures such as lines of text, tokens (for syntax highlighting), etc.

** other embedded objects
:PROPERTIES:
:TS: <2013-01-03 04:06PM>
:ID: nrrkq600azf0
:END:

Arbitrary objects can be embedded in the text. These may contain "clones" of text elsewhere in the document (or in another document, or calculated on the fly).

They are expected to display themselves, just like textual nodes.



* CARD working through wordwrap / tokenization                     :minneron:
:PROPERTIES:
:TS: <2013-01-11 03:17AM>
:ID: f0042s61jzf0
:END:
** NOTE still stuck on wordwrap
:PROPERTIES:
:TS: <2013-01-11 02:15AM>
:ID: v6zgxw31jzf0
:END:
I'm still stuck. I know that word wrap is my next step, but I'm not sure what to do yet.
Does zinput need to change?

Suppose I leave zinput alone as a simple string editor, and I just use it to edit one token at a time. Every time I hit space or enter, I move the editor widget. This is nice, because it means I don't have to change zinput.

It does mean I need to break the file into tokens. Right now, I'm using pascal's standard =ReadLn= function, which simply reads characters until it encounters a platform-specific newline marker.

** NOTE breaking the string into tokens
:PROPERTIES:
:TS: <2013-01-11 03:17AM>
:ID: cpvbjt61jzf0
:END:

* SECTION crawler concept (cursor+stack machine)
:PROPERTIES:
:TS: <2013-01-10 07:43AM>
:ID: vfbhc031izf0
:END:
** TODO add clasp as an actual node type, with left,right, and up pointers.
:PROPERTIES:
:TS: <2013-01-10 08:17AM>
:ID: 9s66sl41izf0
:END:
** TODO add hook as a node type with left, right, and down pointers.
:PROPERTIES:
:TS: <2013-01-10 08:19AM>
:ID: rq33yn41izf0
:END:

* SECTION command dispatch
:PROPERTIES:
:TS: <2013-01-10 07:46AM>
:ID: 6vnhj531izf0
:END:
** the document command language
:PROPERTIES:
:TS: <2013-01-10 07:42AM>
:ID: atnh8y21izf0
:END:
** token-based dispatch
:PROPERTIES:
:TS: <2013-01-10 07:47AM>
:ID: va99k631izf0
:END:
** string-based dispatch
:PROPERTIES:
:TS: <2013-01-10 07:46AM>
:ID: if8k2631izf0
:END:


* SECTION command reference
:PROPERTIES:
:TS: <2013-01-10 08:24AM>
:ID: rfxenx41izf0
:END:
** cursor movement commands
:PROPERTIES:
:TS: <2013-01-10 08:24AM>
:ID: zm4gsw41izf0
:END:
** tree movement commands
:PROPERTIES:
:TS: <2013-01-10 08:31AM>
:ID: 8ybhm851izf0
:END:
** version control commands
:PROPERTIES:
:TS: <2013-01-10 08:32AM>
:ID: wekjl951izf0
:END:
*** undo/redo
:PROPERTIES:
:TS: <2013-01-10 08:32AM>
:ID: 7y602a51izf0
:END:

** string manipulation commands
:PROPERTIES:
:TS: <2013-01-10 08:24AM>
:ID: 8p551x41izf0
:END:
*** TODO insert char
:PROPERTIES:
:TS: <2013-01-10 08:25AM>
:ID: xq7dbz41izf0
:END:
*** TODO delete char
:PROPERTIES:
:TS: <2013-01-10 08:26AM>
:ID: zctajz41izf0
:END:

** compiler commands
:PROPERTIES:
:TS: <2013-01-10 08:25AM>
:ID: yb66dy41izf0
:END:

** range/selection commands
:PROPERTIES:
:TS: <2013-01-10 08:29AM>
:ID: 0izal551izf0
:END:

** token/highlight commands
:PROPERTIES:
:TS: <2013-01-10 08:29AM>
:ID: 9o44r451izf0
:END:
*** set style
:PROPERTIES:
:TS: <2013-01-10 08:29AM>
:ID: c83lc551izf0
:END:
*** break token (space bar)
:PROPERTIES:
:TS: <2013-01-10 08:52AM>
:ID: ps0ca761izf0
:END:

** terminal commands
:PROPERTIES:
:TS: <2013-01-10 08:28AM>
:ID: jntap351izf0
:END:
*** cursor position
:PROPERTIES:
:TS: <2013-01-10 08:28AM>
:ID: x4h40451izf0
:END:
*** set color
:PROPERTIES:
:TS: <2013-01-10 08:28AM>
:ID: b0067451izf0
:END:






* SECTION displaying documents
:PROPERTIES:
:TS: <2013-01-03 04:13PM>
:ID: qbighi00azf0
:END:
** straightforward linear flow display
:PROPERTIES:
:TS: <2013-01-04 04:30AM>
:ID: yb55yly0azf0
:END:

** the scene graph                                                   :later:
:PROPERTIES:
:TS: <2013-01-03 04:16PM>
:ID: iza8lm00azf0
:END:

The block objects serve a secondary purpose, in that they can recursively display themselves (just like widgets in gamesketchlib or whatever).

However, document structure and display structure needn't coincide: nodes might be hidden, or show up at arbitrary coordinates, etc.

So it's likely that each node would have a corresponding display object, which understood coordinates, geometry, etc.

In particular, two clones of the same node would have different geometries and coordinates.

Note also that display nodes may not be textual: raster images, vector shapes, and dialog widgets are all perfectly valid options.


* event dispatcher
Wait for an event, then do something about it.

#+name: procs
#+begin_src pascal
  function readkey( var ch : character ) : char;
  begin
    ch := crt.readkey;
    result := ch
  end;
#+end_src

#+name: vars
#+begin_src pascal
  var ch : char;
#+end_src

#+name: listen
#+begin_src pascal
  case readkey( ch ) of
    #27, ^C : done := true;
    ^N      : next_line;
    ^P      : prev_line;
    ^A      : line_start;
    ^E      : line_end;
    #0      : case crt.readkey of
                #72 : prev_line;  // up
                #80 : next_line;  // down
                #71 : line_start; // home
                #79 : line_end;   // end
                #73 : pageup;
                #81 : pagedown;
              end;
    else self_insert( ch )
  end;
#+end_src

* code layout
:PROPERTIES:
:TS: <2013-01-04 04:30AM>
:ID: amp15ny0azf0
:END:
** FILE buf.pas
:PROPERTIES:
:TS: <2013-01-04 04:31AM>
:ID: u6chgny0azf0
:END:

#+begin_src pascal :tangle ".gen/buf.pas" :padline yes :noweb tangle
  {$i xpc.inc}
  unit buf;
  interface uses xpc, ll, li;
    <<@type:token>>
    <<type:buffer>>
  implementation
  end.
#+end_src

** «main»
#+begin_src pascal :tangle ".gen/mn.pas" :padline yes :noweb tangle
  program mn;
  uses crt, buf;
    <<types>>
    <<vars>>
    <<procs>>
    var quit : boolean = false;
  begin
    <<initialize>>
    repeat
      <<listen>>
      <<update>>
      <<render>>
    until quit
  end.
#+end_src
