#+title: minneron features

* TODO [3/14] general purpose traditional text editor
** DONE [6/6] #ED001 get ln.pas hooked up to cedit.
:PROPERTIES:
:TS: <2013-01-03 01:38PM>
:ID: e526zw719zf0
:END:
*** DONE [3/3] CARD get cedit.pas working again
:PROPERTIES:
:TS:       <2012-11-10 12:42PM>
:ID:       hcg7aat0axf0
:END:
**** DONE pntstuff.pas(66,15) Error: Wrong number of parameters specified for call to "killnode" :bug:
:PROPERTIES:
:TS:       <2012-11-10 12:54PM>
:ID:       st87v6w0axf0
:END:
This just needed an @ to prevent invocation.

**** DONE crtstuff.pas(1472,4) Fatal: Selected assembler reader not supported :bug:
:PROPERTIES:
:TS:       <2012-11-10 01:09PM>
:ID:       uq04zvw0axf0
:END:
***** NOTE basically, crtstuff doesn't compile.
:PROPERTIES:
:TS:       <2012-11-10 01:36PM>
:ID:       65f0e4y0axf0
:END:
***** NOTE workaround: use cw instead ( ?? )
:PROPERTIES:
:TS:       <2012-11-10 01:40PM>
:ID:       dlvgsay0axf0
:END:
***** NOTE . or: just describe the program from the top down
:PROPERTIES:
:TS:       <2012-11-10 01:51PM>
:ID:       qbkefty0axf0
:END:
Maybe rather than trying to compile it, with all those huge broken dependencies, I should just start at the begin section and try and clean it up.
***** NOTE . decided to do both.
:PROPERTIES:
:TS:       <2012-11-10 03:09PM>
:ID:       8k7jrf21axf0
:END:
I commented out most of cedit (anything that relied on my old code, especially). Now I'm going to step through and clean it up a little at a time, making sure it compiles.
***** NOTE . refactoring, test framework, etc
:PROPERTIES:
:TS:       <2012-11-12 01:32PM>
:ID:       ola4zkf0dxf0
:END:
Well, I got cedit to compile at some point in the past few days. I basically commented everything out that wasn't pure pascal, and then re-enabled one line at a time until it compiled. Along the way, I broke crtstuff down into smaller pieces.

Unfortunately, it still doesn't work, so last night I started making a test framework. Actually, I /tried/ to use dunit, but I couldn't get it to compile... And then I decided it was just way bigger and complicated than I really needed anyway. Yes, the gestalt problem again.

Anyway, I wrote my own little test system last night, so today I will track down the bugs in the linked list module by implementing some tests to specify how this thing is supposed to work.

**** DONE cedit shows no text, crashes on arrowdown                  :bug:
:PROPERTIES:
:TS:       <2012-11-12 01:48PM>
:ID:       98dh8bg0dxf0
:END:
***** NOTE repaired ll.append/insert logic, then moved from objects->classes
:PROPERTIES:
:TS:       <2012-11-13 03:25AM>
:ID:       pmcf1l30exf0
:END:
I think probably the code worked before, but I somehow broke things while trying to get it to compile at all. In any case, I now have a test framework cleared out a /bunch/ of duplicate logic from this thing.

Still have one bug, but it's in ~cw.pas~, not ~cedit~, so I'm going to mark this done! :)
*** DONE [0/0] create a simple line editor ( ui.zinput as reference? )
:PROPERTIES:
:TS:       <2012-11-10 02:37PM>
:ID:       fr78ey01axf0
:END:
*** DONE [2/2] build oberon-style "text" (ll of strings + markers)
:PROPERTIES:
:TS:       <2012-11-13 11:53AM>
:ID:       w4q793r0exf0
:END:
**** DONE [0/0] create a token type
:PROPERTIES:
:TS: <2013-01-01 10:45PM>
:ID: ez8ho0117zf0
:END:
[0104.2013 04:54AM] done in type token (really same as li.strtoken)

**** DONE [0/0] create linked list of tokens
:PROPERTIES:
:TS: <2013-01-01 10:47PM>
:ID: 06kgs4117zf0
:END:
[0104.2013 04:55AM] done in type tagtoken = li.objtoken

*** DONE [0/0] convert cedit to use the buffer type
:PROPERTIES:
:TS: <2013-01-04 04:56AM>
:ID: f7a9vtz0azf0
:END:

I suppose in this case, we want to use elements/blocks.

Looks like it's already using stringnodes, but that's pretty much the same as li.strnode, so i might as well use a list of li.nodes. But I'll go ahead and use the buffer type I created in mn.trail.

Another thing I did was make the editor class (previously =listeditor=) be a container for a buffer, rather than a subclass.

*** DONE [0/0] read lines of text as the initial chunks
:PROPERTIES:
:TS: <2013-01-01 10:46PM>
:ID: kozjs1117zf0
:END:

This was already done in cedit too. :)


*** DONE [0/0] show the line editor on the highlighted line
:PROPERTIES:
:TS: <2013-01-04 07:15AM>
:ID: th42v961azf0
:END:

** DONE [4/6] #ED002 break / join lines in editor
:PROPERTIES:
:TS: <2013-01-03 01:40PM>
:ID: 3kd48z719zf0
:END:
*** DONE break
:PROPERTIES:
:TS: <2013-01-07 01:46PM>
:ID: fccivi70fzf0
:END:

Breaking lines simply means that when the enter key is pressed:

  - everything to the right of the cursor is moved to a new string-node
  - the new string node is inserted inline in the buffer

*** DONE update cursors after break (editor.position and led.cpos)
:PROPERTIES:
:TS: <2013-01-07 05:49PM>
:ID: yux1esi0fzf0
:END:

*** DONE join lines when deleting newline
:PROPERTIES:
:TS: <2013-01-07 01:45PM>
:ID: eyzbcg70fzf0
:END:

*** DONE update cursor index after deleting (unecessary!)
:PROPERTIES:
:TS: <2013-01-07 05:49PM>
:ID: yux1esi0fzf0
:END:

Actually, when you delete the newline, the cursor stays in the same place.

*** TODO also join lines when backspacing through newline
:PROPERTIES:
:TS: <2013-01-07 11:54PM>
:ID: ouhg8oz0fzf0
:END:

This can wait.

*** TODO update /all/ attached cursors when inserting items into the list
:PROPERTIES:
:TS: <2013-01-07 06:42PM>
:ID: 8zt2b8l0fzf0
:END:
    { append this cursor to the array so we get notified of inserts/deletes }
    len := length( lis._cursors );
    setlength( lis._cursors, len + 1 );
    lis._cursors[ len ] := self;

test case:
    { when we insert, the cursors should update }
    ls.insert( a );
    chk.equal( ls.count, 3 );
    chk.that( cur.index = 3, 'cursor index didn''t update after insertion' );
    chk.equal( cur.index, 3 );

** DONE [0/0] #ED003 save the updated file to disk
:PROPERTIES:
:TS: <2013-01-03 01:40PM>
:ID: nfe6rz719zf0
:END:

** TODO [0/0] #ED004 word wrap / virtual line mode
:PROPERTIES:
:TS: <2013-01-03 01:41PM>
:ID: qr35d0819zf0
:END:
** TODO [0/0] #ED005 regions (selections, highlights, etc)
:PROPERTIES:
:TS: <2013-01-03 01:41PM>
:ID: s36461819zf0
:END:
** TODO [0/0] #ED006 cut, copy, paste
:PROPERTIES:
:TS: <2013-01-03 01:42PM>
:ID: xdmg02819zf0
:END:
** TODO [0/0] #ED007 show/hide individual blocks
:PROPERTIES:
:TS: <2013-01-03 01:42PM>
:ID: r2n8o2819zf0
:END:
** TODO [0/0] #ED008 move blocks inside the outline
:PROPERTIES:
:TS: <2013-01-03 01:42PM>
:ID: ug5a73819zf0
:END:
** TODO [0/0] #ED009 styles for blocks
:PROPERTIES:
:TS: <2013-01-03 01:43PM>
:ID: lnl744819zf0
:END:
** TODO [0/0] #ED010 tokenize/highlight within blocks
:PROPERTIES:
:TS: <2013-01-03 01:43PM>
:ID: cti3s4819zf0
:END:
** TODO [0/0] #ED011 tabular blocks
:PROPERTIES:
:TS: <2013-01-03 01:44PM>
:ID: 0bbcs5819zf0
:END:
** TODO [0/0] #ED012 tangle (generate source files)
:PROPERTIES:
:TS: <2013-01-03 01:44PM>
:ID: fx00t6819zf0
:END:
** TODO [0/0] #ED013 weave (generate html site)
:PROPERTIES:
:TS: <2013-01-03 01:45PM>
:ID: l0e2c8819zf0
:END:
** TODO [0/0] #ED014 trailblaze (weave + version control)
:PROPERTIES:
:TS: <2013-01-03 01:46PM>
:ID: wqf1y8819zf0
:END:



* [0/0] -- unfiled ---
:PROPERTIES:
:TS: <2013-01-07 01:45PM>
:ID: abbhsg70fzf0
:END:
** TODO [0/0] build the block-based display engine (console based)
:PROPERTIES:
:TS: <2013-01-01 10:35PM>
:ID: tm74ek017zf0
:END:

** TODO [0/0] build the command interpreter
:PROPERTIES:
:TS: <2013-01-01 10:35PM>
:ID: 6v09mj017zf0
:END:

** TODO [0/0] load entire files directly into ram
:PROPERTIES:
:TS:       <2012-11-10 12:21PM>
:ID:       hpwbsmu0axf0
:END:
Rather than deal with the bytestream protocol, just load the files directly into ram, and deal with them there. This gives us random access, etc.

** TODO [0/0] simple syntax highlighting / tokenization
:PROPERTIES:
:TS:       <2012-11-13 11:42AM>
:ID:       n7z7sjq0exf0
:END:

** TODO [0/2] harvest other editors ( once I have core editor working in pascal )
:PROPERTIES:
:TS:       <2012-11-13 11:42AM>
:ID:       kt1h6kq0exf0
:END:
*** TODO [0/0] harvest diakonos
:PROPERTIES:
:TS:       <2012-11-13 11:40AM>
:ID:       5g1jugq0exf0
:END:
*** TODO [0/0] harvest codemirror
:PROPERTIES:
:TS:       <2012-11-13 11:42AM>
:ID:       ccr0wkq0exf0
:END:


** TODO [0/0] [#A] parse org files - see file:~/r/@code/@py/o2x.py
:PROPERTIES:
:TS:       <2012-11-10 11:18AM>
:ID:       d0c5kpr0axf0
:END:

** TODO [0/0] load/save minno
:PROPERTIES:
:TS:       <2012-11-10 11:46AM>
:ID:       det2o1t0axf0
:END:
** TODO [0/0] graph database ( port amoeba to pascal )
:PROPERTIES:
:TS:       <2012-11-13 11:26AM>
:ID:       bnyckup0exf0
:END:
** TODO [0/2] multi-colum / table based editor
:PROPERTIES:
:TS:       <2012-11-10 11:27AM>
:ID:       0knej5s0axf0
:END:
*** TODO [0/0] merge in file:~/r/work/griddemo.pas
:PROPERTIES:
:TS:       <2012-11-13 10:48AM>
:ID:       re6c12o0exf0
:END:
*** TODO [0/0] simple table-based editor
:PROPERTIES:
:TS:       <2012-11-10 02:30PM>
:ID:       uhv4ml01axf0
:END:
load arrays of nodes
*** TODO [0/0] cw's end of line handling breaks ( on linux, anyway ).
:PROPERTIES:
:TS:       <2012-11-13 03:29AM>
:ID:       mmherr30exf0
:END:
This could be compounded by the fact that I'm also trying to use kvm.

** TODO [0/1] database forms
:PROPERTIES:
:TS:       <2012-11-13 11:48AM>
:ID:       eso31uq0exf0
:END:
*** TODO [0/0] I think ymenu has a basic form. I could mix with html/django form model
:PROPERTIES:
:TS:       <2012-11-13 11:48AM>
:ID:       xov0muq0exf0
:END:
** TODO [0/2] trailblazer / tangentcode editor ( graph db programming )
:PROPERTIES:
:TS:       <2012-11-13 11:37AM>
:ID:       cxqhvbq0exf0
:END:
*** TODO [0/2] get all my pascal code into a database
:PROPERTIES:
:TS:       <2012-11-10 12:42PM>
:ID:       k1b2zlv0axf0
:END:
maybe use the code tools?

**** TODO convert old pascal source files to unicode
:PROPERTIES:
:TS:       <2012-11-10 02:21PM>
:ID:       gs594801axf0
:END:


**** TODO parse pascal/oberon/turbo                               :parser:
:PROPERTIES:
:TS:       <2012-11-10 01:50PM>
:ID:       yv64pry0axf0
:END:
*** TODO [0/0] implement org-babel-tangle
:PROPERTIES:
:TS:       <2012-11-13 11:06AM>
:ID:       ls96dwo0exf0
:END:
** TODO [0/2] task oriented, tiling window enviroment ( minneron )
:PROPERTIES:
:TS:       <2012-11-13 11:30AM>
:ID:       v735uzp0exf0
:END:
*** TODO [0/0] get tmux to work sort of like autohotkey              :tmux:
:PROPERTIES:
:TS:       <2012-11-10 11:18AM>
:ID:       mpj2aqr0axf0
:END:
*** graphical tmux-like thing for windows ( but with browsers, etc )
:PROPERTIES:
:TS:       <2012-11-10 11:18AM>
:ID:       23q5upr0axf0
:END:
Could use windows API, or mozilla.
*** i want to unify the emacs and tmux keybindngs                    :tmux:
:PROPERTIES:
:TS:       <2012-11-10 11:18AM>
:ID:       5yfj6qr0axf0
:END:
especially for switching / resizing windows
C-x | to do vertical split, maybe?
*** WANT browser keybidings for scroll, etc                       :browser:
:PROPERTIES:
:TS:       <2012-11-10 11:20AM>
:ID:       kjx0ctr0axf0
:END:
i wish i could use my normal keybindings for paging, etc in the browser
**** TODO try conkeror
:PROPERTIES:
:TS:       <2012-11-10 11:21AM>
:ID:       4dmjvur0axf0
:END:
*** TODO console web browsers
