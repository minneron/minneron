* structural view (interface declaraions)                            :st:min:
:PROPERTIES:
:TS: <2013-01-11 11:21AM>
:ID: 02li6ne0kzf0
:ARCHIVE_TIME: 2013-01-13 Sun 09:17
:ARCHIVE_FILE: ~/r/minneron/min.org
:ARCHIVE_CATEGORY: min
:END:
** TODO ngaro virtual machine <done but need defs here>                 :vm:
:PROPERTIES:
:TS: <2013-01-11 03:35AM>
:ID: la310m71jzf0
:END:
** [1/3] document model (spanning tree into the graph)                  :doc:
:PROPERTIES:
:TS: <2013-01-03 04:13PM>
:ID: v971ih00azf0
:END:
*** TYPE buffer
:PROPERTIES:
:TS: <2013-01-04 02:51AM>
:ID: o6e3l1u0azf0
:END:

The buffer is a simple, linear list of tokens, where tokens are either strings, or invisible markers pointing to document nodes.

#+name: type:buffer
#+begin_src pascal
  type buffer = li.nodelist;
#+end_src

*** TYPE token
:PROPERTIES:
:TS: <2013-01-12 06:41AM>
:ID: x4i08sh0lzf0
:END:

#+name: type:token
#+begin_src pascal
  type token = li.strnode;
#+end_src

Just plain old string nodes for now.

*** TYPE anchor                                                    :unused:
:PROPERTIES:
:TS: <2013-01-04 02:09AM>
:ID: 2mxaf3s0azf0
:END:

#+name: type:anchor
#+begin_src pascal
  type anchor = li.objnode;
#+end_src

Anchors are non-textual, and may hold any kind of data. They correspond roughly to <A> tags in html.

Unlike the generic list cursors, which are pointers to link objects in the linked list, anchors are data objects that are actually part of the buffer. This is so programs that traverse the list are able to see and make use of them.

*** TYPE element
:PROPERTIES:
:TS: <2013-01-12 03:20PM>
:ID: 8br01s51lzf0
:END:

#+name: type:element
#+begin_src pascal
  type element = li.lisnode;
#+end_src

*** TODO blocks
:PROPERTIES:
:TS: <2013-01-03 03:53PM>
:ID: s5pjy4e19zf0
:END:

Blocks are spans that act like xml elements, in that they are nestable but non-overlapping, and that each node in the tree contains references to its siblings, children, and a single parent node.

Aside from these fields, blocks can be of any type, and may or may not conform to any particular schema.

Most likely they would be implemented as =type generic block<t>=.

These can be used to indicate parsed structures such as lines of text, tokens (for syntax highlighting), etc.

*** DONE TYPE span
:PROPERTIES:
:TS: <2013-01-03 03:57PM>
:ID: f4x29ce19zf0
:END:
#+name: type:span
#+begin_src pascal
  { used for selections }
  type generic span<t> = class
  public
    type tag = class( anchor )
      is_start, is_end : boolean;
      span             : specialize span<t>;
    end;
  public
    start_tag, end_tag : tag;
    obj : t;
  end;
#+end_src

*** TODO other embedded objects
:PROPERTIES:
:TS: <2013-01-03 04:06PM>
:ID: nrrkq600azf0
:END:

Arbitrary objects can be embedded in the text. These may contain "clones" of text elsewhere in the document (or in another document, or calculated on the fly).

They are expected to display themselves, just like textual nodes.

** TODO user interface                                                  :ui:
:PROPERTIES:
:TS: <2013-01-11 11:07AM>
:ID: lb6auzd0kzf0
:END:
*** TODO line editor
:PROPERTIES:
:TS: <2013-01-11 11:22AM>
:ID: 2cxcdoe0kzf0
:END:

*** DONE editor type                                                   :ed:
:PROPERTIES:
:TS: <2013-01-11 11:09AM>
:ID: zy54y2e0kzf0
:END:
#+name: type:editor
#+begin_src pascal
  type editor = class
    buf               : buf.buffer;
    filename          : string;
    message           : string;
    x, y, h, w        : integer;
    topline, position : buf.buffer.cursor;
    led               : ui.zinput;  // led = Line EDitor
    constructor create;
    function load( path : string ) : boolean;
    function save_as( path : string ) : boolean;
    function save : boolean;
    procedure run;
    procedure show;
  
   protected { cursor movement commands }
    procedure arrowup;
    procedure arrowdown;
    procedure home;
    procedure _end;
    procedure pageup;
    procedure pagedown;
  
   protected { line manipulation commands }
    procedure newline;
    procedure delete;
  
   private
    procedure updateCamera;
    procedure keepInput;
    procedure moveInput;
    function wrap( s : string ) : li.strnode;
    procedure parse( var txt : text );
  end;
  
#+end_src

** TODO database                                                        :mr:
:PROPERTIES:
:TS: <2013-01-11 11:21AM>
:ID: ae267me0kzf0
:END:
