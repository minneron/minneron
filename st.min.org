* structural view (interface declaraions)                            :st:min:
:PROPERTIES:
:TS: <2013-01-11 11:21AM>
:ID: 02li6ne0kzf0
:ARCHIVE_TIME: 2013-01-13 Sun 09:17
:ARCHIVE_FILE: ~/r/minneron/min.org
:ARCHIVE_CATEGORY: min
:END:
** TODO ngaro virtual machine <done but need defs here>                 :vm:
:PROPERTIES:
:TS: <2013-01-11 03:35AM>
:ID: la310m71jzf0
:END:
** interface for unit =mnml=
:PROPERTIES:
:TS:       <2013-05-15 10:19AM>
:ID:       ab9hx2x034g0
:END:
#+name: mnml:interface
#+begin_src pascal
  type
    TVoRun = function : vor of object;
    TThunk = procedure;
    TToken = string[31];
    TCmdId = cardinal;
  
  procedure define( out cmd : TCmdId; thunk : TThunk; token : TToken );
  procedure init; overload;
  procedure init(shell : IVorTask); overload;
  procedure launch( const cmd : TCmdId ); overload;
  procedure launch( const cmd : TToken ); overload;
  procedure launch( task : IVorTask ); overload;
  procedure step;
  function  done : boolean;
  procedure loop;
#+end_src



*** [1/6] document model (spanning tree into the graph)       :doc:
:PROPERTIES:
:TS: <2013-01-03 04:13PM>
:ID: v971ih00azf0
:END:
**** TYPE =TBuffer=
:PROPERTIES:
:TS: <2013-01-04 02:51AM>
:ID: o6e3l1u0azf0
:END:

A =TBuffer= is essentially a composite version of =ITextTile=.

#+name: type:TBuffer
#+begin_src pascal
  type
    TBuffer = class (TTextTile)
      private type
        TTextNodes = GRing<string>;
        ITextCursor = IRingCursor<string>;
        cursor = ITextCursor;
      private
        nodes : TTextNodes;
      public
        constructor Create( w, h : cardinal );
        function  GetLength : cardinal; override;
        function  GetLine(i:cardinal) : string; override;
        procedure SetLine(i:cardinal; s:string); override;
        procedure InsLine(i:cardinal; s:string); override;
        procedure AddLine(s:string); override;
        procedure DelLine(i:cardinal); override;
        property length : cardinal read GetLength;
        property lines[i:cardinal]:string
          read GetLine write SetLine; default;
      end;
#+end_src

**** TODO TYPE token                                         :unused:
:PROPERTIES:
:TS: <2013-01-12 06:41AM>
:ID: x4i08sh0lzf0
:END:

#+name: type:token
#+begin_src pascal
  type token = string;
#+end_src

Just plain old string nodes for now.

**** TODO TYPE anchor                                        :unused:
:PROPERTIES:
:TS: <2013-01-04 02:09AM>
:ID: 2mxaf3s0azf0
:END:

#+name: type:anchor
#+begin_src pascal
  type anchor = TObject;
#+end_src

Anchors are non-textual, and may hold any kind of data. They correspond roughly to <A> tags in html.

Unlike the generic list cursors, which are pointers to link objects in the linked list, anchors are data objects that are actually part of the buffer. This is so programs that traverse the list are able to see and make use of them.

**** TODO TYPE element                                       :unused:
:PROPERTIES:
:TS: <2013-01-12 03:20PM>
:ID: 8br01s51lzf0
:END:

#+name: type:element
#+begin_src pascal
//  type element = li.lisnode;
#+end_src

**** TODO blocks
:PROPERTIES:
:TS: <2013-01-03 03:53PM>
:ID: s5pjy4e19zf0
:END:

Blocks are spans that act like xml elements, in that they are nestable but non-overlapping, and that each node in the tree contains references to its siblings, children, and a single parent node.

Aside from these fields, blocks can be of any type, and may or may not conform to any particular schema.

Most likely they would be implemented as =type block<t>=.

These can be used to indicate parsed structures such as lines of text, tokens (for syntax highlighting), etc.

**** DONE TYPE span
:PROPERTIES:
:TS: <2013-01-03 03:57PM>
:ID: f4x29ce19zf0
:END:
#+name: type:span
#+begin_src pascal
  { used for selections }
  type GSpan<t> = class
  public
    type tag = class( anchor )
      is_start, is_end : boolean;
      span             : GSpan<T>;
    end;
  public
    start_tag, end_tag : tag;
    obj : t;
  end;
#+end_src

**** TODO other embedded objects
:PROPERTIES:
:TS: <2013-01-03 04:06PM>
:ID: nrrkq600azf0
:END:

Arbitrary objects can be embedded in the text. These may contain "clones" of text elsewhere in the document (or in another document, or calculated on the fly).

They are expected to display themselves, just like textual nodes.

*** TODO editor user interface                                :ui:
:PROPERTIES:
:TS: <2013-01-11 11:07AM>
:ID: lb6auzd0kzf0
:END:
**** TODO line editor
:PROPERTIES:
:TS: <2013-01-11 11:22AM>
:ID: 2cxcdoe0kzf0
:END:

**** DONE TEditor type                                       :ed:
:PROPERTIES:
:TS: <2013-01-11 11:09AM>
:ID: zy54y2e0kzf0
:END:
***** TEditor > the basics
#+name: type:TEditor
#+begin_src pascal
  type TEditor = class (TVorTask)
    buf               : ITextTile;
    filename          : string;
    message           : string;
    x, y, h, w        : integer;
    topline, position : cardinal;
    led               : ui.zinput;  // led = (L)ine (ED)itor
    state             : vor;
    constructor Create;
    function Load( path : string ) : boolean;
    function Save_as( path : string ) : boolean;
    function Save : boolean;
    procedure Loop;
    procedure Init;
    procedure OnKeyPress;
    procedure Draw;
    function Done : boolean;
#+end_src

***** TEditor > cursor movement
#+name: type:TEditor
#+begin_src pascal
   protected { cursor movement commands }
    procedure arrowup;
    procedure arrowdown;
    procedure home;
    procedure _end;
    procedure pageup;
    procedure pagedown;
#+end_src

***** TEditor > line manipulation
#+name: type:TEditor
#+begin_src pascal
   protected { line manipulation commands }
    procedure newline;
    procedure delete;
#+end_src

***** TEditor > misc private methods
#+name: type:TEditor
#+begin_src pascal
   private
    procedure updateCamera;
    procedure grabLine;
    procedure keepInput;
    procedure moveInput;
    procedure parse( var txt : text );
  end;
  
#+end_src

*** TODO database                                             :mr:
:PROPERTIES:
:TS: <2013-01-11 11:21AM>
:ID: ae267me0kzf0
:END:
