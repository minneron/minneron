#+title: procedural view (current procedure/method definitions)
#+tags: pr min
#+date: <2013-01-11 11:07AM>

* implementation for =mnml=
:PROPERTIES:
:TS:       <2013-05-15 11:14AM>
:ID:       y8n1knz034g0
:END:
** internal variables
#+name: mnml:implementation
#+begin_src pascal
  implementation
    var
      queue  : array of TCmdId;
      thunks : array of TThunk;
      tokens : array of TToken;
  #+end_src

** =step=
:PROPERTIES:
:TS:       <2013-05-15 10:13AM>
:ID:       uxv9rtw034g0
:END:
#+name: mnml:implementation
#+begin_src pascal
  procedure step;
    var i, n : cardinal;
    begin
      n := length(queue);
      if n > 0 then for i := 0 to n - 1 do thunks[queue[i]]();
      if length(queue) > n then
        { shift newly launched commands to start of the array }
        for i := n to length(queue) - 1 do queue[i-n] := queue[i];
      { now truncate the array so only the new items remain }
      SetLength(queue, Length(queue)-n)
    end;
#+end_src

** =loop=
:PROPERTIES:
:TS:       <2013-05-15 10:02AM>
:ID:       vkn7ibw034g0
:END:
#+name: mnml:implementation
#+begin_src pascal
  procedure loop;
    begin
      repeat step until done
    end;
#+end_src
** =done=
:PROPERTIES:
:TS:       <2013-05-15 11:46AM>
:ID:       14ted41134g0
:END:
#+name: mnml:implementation
#+begin_src pascal
  function done : boolean; inline;
    begin
      done := length(queue) = 0;
    end;
#+end_src

** =define=
:PROPERTIES:
:TS:       <2013-05-15 11:46AM>
:ID:       hdeho31134g0
:END:
#+name: mnml:implementation
#+begin_src pascal
  procedure define( out cmd : TCmdId; thunk : TThunk; token : TToken );
    begin
      cmd := length(thunks);
      setlength(thunks, cmd+1);
      setlength(tokens, cmd+1);
      thunks[cmd] := thunk;
      tokens[cmd] := token;
    end;
#+end_src

** =launch=
:PROPERTIES:
:TS:       <2013-05-15 11:46AM>
:ID:       tey0a41134g0
:END:
#+name: mnml:implementation
#+begin_src pascal
  procedure launch( const cmd  : TCmdId );
    begin
      setlength(queue, length(queue)+1);
      queue[cmd] := cmd;
    end;
  
  procedure launch( const cmd  : TToken );
    var i : cardinal; found : boolean = false;
    begin
      for i := 0 to length(queue)-1 do
        if tokens[i]=cmd then 
          begin
            launch( i );
            found := true;
          end;
      if not found then
        raise Exception.Create('undefined: ' + cmd );
    end;
#+end_src





* CLASS =TBuffer=
:PROPERTIES:
:TS:       <2013-09-28 12:22PM>
:ID:       yzpkt73039g0
:END:
** constructors
:PROPERTIES:
:TS:       <2013-09-28 08:22PM>
:ID:       6fsb1gp039g0
:END:
#+name: @imp:TBuffer
#+begin_src pascal

  constructor TBuffer.Create( w, h : cardinal );
    begin
      inherited Create( w, h );
      nodes := TTextNodes.Create;
    end;

#+end_src

** =ITextTile= methods
:PROPERTIES:
:TS:       <2013-09-28 08:21PM>
:ID:       3awb6ep039g0
:END:
#+name: @imp:TBuffer
#+begin_src pascal

  function TBuffer.GetLength : cardinal;
    begin
      result := nodes.Length;
    end;

  function TBuffer.GetLine(i:cardinal) : string;
    begin
      result := nodes[i];
    end;

  procedure TBuffer.SetLine(i:cardinal; s:string);
    begin
      nodes[i] := s;
    end;

  procedure TBuffer.AddLine(s:string);
    begin
      nodes.append(s)
    end;

  procedure TBuffer.InsLine(i:cardinal; s:string);
    begin
      nodes.InsertAt(i, s)
    end;

  procedure TBuffer.DelLine(i:cardinal);
    begin
      nodes.DeleteAt(i);
    end;

#+end_src


* CLASS TEditor                                                  :ed:
:PROPERTIES:
:TS: <2013-01-11 08:46AM>
:ID: sghf0g70kzf0
:END:
** constructor
:PROPERTIES:
:TS: <2013-01-12 07:37AM>
:ID: 7hd3ldk0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  constructor TEditor.create;
    begin
      inherited;
      x := 0;
      y := 0;
      w := kvm.width;
      h := kvm.height;
      self.buf := TBuffer.create(w, h - 1);
      topline := 0;
      position := 0;
      filename := '';
      message  := 'welcome to minneron.';
    end;
#+end_src

** TODO «tokenizer» interface { extract tokenizer stuff }
:PROPERTIES:
:TS: <2013-01-11 05:05AM>
:ID: er586tb1jzf0
:END:
#+name: @imp:ed
#+begin_src pascal

  procedure TEditor.parse( var txt : text );
    var n : cardinal; line : string;
    begin
      while not eof( txt ) do begin
        readln( txt, line );
        self.buf.AddLine( line );
{
        words := nodelist.create;
        if length( line ) > 0 then
          for n := 1 to stri.nwords( line ) do begin
            log.debug([ 'word ', n, ' : ', stri.wordn( line, n ) ]);
            words.append( wrap( stri.wordn( line, n )));
          end;
        self.buf.append( li.lisnode.create( words ));
        log.debug([ 'words: ', n, ' line: "' + line + '" length: ', length( line ) ]);
}
      end;
      // li.print( lisnode.create( self.buf ));
    end;
#+end_src

** disk interface
:PROPERTIES:
:TS: <2013-01-12 07:38AM>
:ID: f41aqek0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  function TEditor.Load( path : string ) : boolean;
      var txt : text;
    begin
      result := fs.exists( path );
      if result then
        begin
          //  need to check for io errors in here
          assign( txt, path );
          reset( txt );
          self.parse( txt );
          close( txt );
          self.filename := path;
        end
      else message := 'couldn''t load "' + path + '"';
    end; { TEditor.load }

  function TEditor.save : boolean;
      var txt: text; i : cardinal;
    begin
      assign( txt, self.filename );
      rewrite( txt );
      for i := 0 to self.buf.length -1 do writeln(txt, buf[i]);
      close( txt );
      result := true; // TODO error checking
      message := filename + ' saved.';
    end;

  function TEditor.save_as( path : string ) : boolean;
      var oldname : string;
    begin
      oldname := self.filename;
      self.filename := path;
      result := self.save;
      if not result then self.filename := oldname
    end;

#+end_src

** display
:PROPERTIES:
:TS: <2013-01-12 07:39AM>
:ID: 1oyksgk0lzf0
:END:
*** TEditor.draw
:PROPERTIES:
:TS: <2013-01-13 04:33AM>
:ID: l0l8ixr0mzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  procedure TEditor.draw;
    var
      ypos : cardinal;
      line : cardinal;
      <<ed/draw/curpos>>
      <<ed/draw/gutter>>
      <<ed/draw/PlaceEditor>>
      <<ed/draw/line>>
    begin
      <<ed/draw:main>>
    end;
#+end_src
**** «ed/draw/curpos»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: j4k6vzr0mzf0
:END:
#+name: ed/draw/curpos
#+begin_src pascal
  procedure draw_curpos;
  begin
    cwritexy( 0, 0,
              '|!b' +
              '|B[|C' + flushrt( n2s( self.position ), 6, '.' ) +
              '|w/|c' + flushrt( n2s( self.buf.length ), 6, '.' ) +
              '|B]|Y ' + self.message +
           '|%' );
    self.message := '';
  end;
#+end_src
**** «ed/draw/gutter»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: dfe840s0mzf0
:END:
#+name: ed/draw/gutter
#+begin_src pascal
  procedure draw_gutter( s : string );
    var color : char = 'c';
  begin
    if line = position then color := 'C';
    cwritexy( 0, ypos, '|k|!' + color + s + '|!k|w' );
  end;
#+end_src
**** «ed/draw/edit»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: de5ca0s0mzf0
:END:
#+name: ed/draw/PlaceEditor
#+begin_src pascal
  procedure PlaceEditor;
  begin
    { This simply positions the input widget. }
    with self.led do begin
      x := cw.cur.x;
      y := cw.cur.y;
      tcol := $080f;
      dlen := cw.max.x - cw.cur.x
    end;
  end;
#+end_src
**** «ed/draw/line»
#+name: ed/draw/line
#+begin_src pascal
  procedure draw_line(s:string);
    begin
      cwrite(s + '|!k|%' );
    end;
#+end_src
**** TODO «ed/draw/node» { move =draw_node= logic to =TBuffer= }
:PROPERTIES:
:TS: <2013-01-13 04:48AM>
:ID: 51l0hns0mzf0
:END:
#+name: draw_node
#+begin_src pascal

  procedure draw_list(node:li.lisnode);
    var
      tok   : string;
      d2re  : cardinal; { distance to right edge }
      child : li.node;
    begin
      for child in node.lis do
        begin
          d2re := cw.scr.w - cw.cur.x;
          if child is li.strnode
            then tok := (child as li.strnode).str
            else tok := '|r<??>|w';
          tok += '|b.|w'; //  b/c tokenizer strips ws
          {-- word wrapping --}
          if length( tok ) < d2re then cwrite( tok )
          else begin
            cwrite( '|!k|%' ); // clreol
            inc( ypos );
            draw_gutter( '   ' );
            { truncate, in case token is wider than the whole editor }
            cwrite( stri.trunc( tok, d2re ));
          end
        end;
    end;

#+end_src

**** «ed/draw:main»
:PROPERTIES:
:TS: <2013-01-13 04:40AM>
:ID: 9u9baas0mzf0
:END:
#+name: ed/draw:main
#+begin_src pascal
    begin
      HideCursor;
      cwrite('|w|!b');
      //todo  fillbox( 1, 1, kvm.maxX, kvm.maxY, $0F20 );
      draw_curpos;
      ypos := 1; // line 0 is for the status / cursor position

      line := topline;
      repeat
        draw_gutter( flushrt( n2s( line ), 3, ' ' ));
        if line = position then PlaceEditor
        else draw_line(buf[line]);
        inc( ypos ); inc(line)
      until ( ypos >= self.h ) or ( line = buf.length );
      { fill in extra space if the file is too short }
      while ypos < self.h do begin
        cwritexy( 0, ypos, '|!K|%' );
        inc( ypos )
      end;
      led.show;
      // ShowCursor;
    end;
#+end_src
*** the 'camera'
:PROPERTIES:
:TS: <2013-01-17 07:42AM>
:ID: 34mdyie1rzf0
:END:
**** «updateCamera»
:PROPERTIES:
:TS: <2013-01-17 07:42AM>
:ID: 3j1bdje1rzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  procedure TEditor.updatecamera;
    var screenline : word;
    begin
      assert(topline <= position );
      screenline := position - topline;
      if ( screenline < 5 ) and ( topline > 1 ) then
        begin
          dec(topline)
          //  scrolldown1(1,80,y1,y2,nil);
          //  scrolldown1(1,80,14,25,nil);
        end
      else if ( screenline > self.h - 5 )
        and ( self.topline < self.buf.length ) then
        begin
          inc( topline );
          //  scrollup1(1,80,y1,y2,nil);
          //  scrollup1(1,80,14,25,nil);
        end
    end;
#+end_src

** cursor movement interface
:PROPERTIES:
:TS: <2013-01-12 07:41AM>
:ID: 34ca2jk0lzf0
:END:
*** home/end
:PROPERTIES:
:TS: <2013-01-17 07:32AM>
:ID: spi8g1e1rzf0
:END:

#+name: @imp:ed
#+begin_src pascal

  procedure TEditor.home;
  begin
    if self.buf.length = 0 then exit;
    position := 0;
    topline := 0;
    led.work := buf[ 0 ];
  end;

  procedure TEditor._end;
    var i : byte;
  begin
    position := self.buf.length - 1;
    topline := position;
    for i := kvm.maxY div 2 downto 1 do dec(topline);
  end;
#+end_src

*** up/down motion
:PROPERTIES:
:TS: <2013-01-17 07:31AM>
:ID: t7d7f0e1rzf0
:END:
#+name: @imp:ed
#+begin_src pascal

  procedure TEditor.grabLine;
   { TODO: see if this code belongs in TBuffer. Else delete it.
    function to_string : string;
      var first : boolean = true; var this, node : li.node;
      begin
        result := '';
        this := self.position.value;
        case this.kind of
          KSTR :
             result := (this as li.strnode).str;
          KLIS :
            for node in (this as li.lisnode).lis do
              begin
                if first then first := false
                else result += ' ';
                result += (node as li.strnode).str;
              end
          else pass
        end
      end;
     }
    begin
      self.led.work := self.buf[self.position]
    end;

  procedure TEditor.arrowup;
    begin
      keepInput;
      if self.position > 0 then
        begin
          dec(self.position);
          moveInput;
        end;
      grabLine;
    end;

  procedure TEditor.arrowdown;
    begin
      keepInput;
      if self.position + 1 < self.buf.length then
        begin
          inc(self.position);
          moveInput;
        end;
      grabLine;
    end;

  procedure TEditor.pageup;
    var c : byte;
    begin
      for c := 1 to h do arrowup;
    end;

  procedure TEditor.pagedown;
    var c : byte;
    begin
      for c := 1 to h do arrowdown;
    end;

#+end_src

** TODO managing the zinput control
:PROPERTIES:
:TS: <2013-01-17 07:50AM>
:ID: qcp4cc00szf0
:END:
#+name: @imp:ed
#+begin_src pascal
  procedure TEditor.keepInput;
  begin
    buf[position] := led.value
  end;
#+end_src

#+name: @imp:ed
#+begin_src pascal
  procedure TEditor.moveInput;
  begin
    updateCamera;
  end;
#+end_src

** =loop= and =step=
:PROPERTIES:
:TS: <2013-01-12 07:41AM>
:ID: lxfhwjk0lzf0
:END:

#+name: @imp:ed
#+begin_src pascal
  
  procedure TEditor.Loop;
    begin
      init;
      repeat
        draw;
        repeat 
          if not keypressed then sleep(50);
        until keypressed;
        onKeyPress;
      until state = TI;
      done;
    end;
  
  procedure TEditor.Init;
    begin
      self.led := ui.zinput.create;
      self.home;
    end;
  
  procedure TEditor.onKeyPress;
    var ch: char;
    begin
      case kbd.readkey(ch) of
        ^C : self.state := TI;
        ^R : begin HideCursor; mnml.launch(cmd_rnd); end;
        ^N : arrowdown;
        ^P : arrowup;
        ^M : newline;
        ^D : delete;
        ^S : save;
        ^V : pagedown;
        ^U : pageup;
        #0 : case kbd.readkey(ch) of
               #72 : arrowup; // when you press the UP arrow!
               #80 : arrowdown; // when you press the DOWN arrow!
               #71 : home;
               #79 : _end;
               #73 : pageup;
               #81 : pagedown;
               ^M  : newline;
               else led.handlestripped( ch ); led.show;
             end;
        else led.handle( ch ); led.show;
      end;
      led.isdone := false;
    end;
  
  function TEditor.Done : boolean;
    begin
      result := self.state = TI
    end;
  
#+end_src

** multi-line editor commands
:PROPERTIES:
:TS: <2013-01-12 07:42AM>
:ID: pn7bmlk0lzf0
:END:

#+name: @imp:ed
#+begin_src pascal
  procedure TEditor.newline;
    begin
      buf.InsLine(position, led.str_to_end );
      led.del_to_end;
      arrowdown;
      led.to_start;
    end;

  procedure TEditor.delete;
    begin
      if led.at_end and (position + 1 < buf.length) then
        begin
          led.work += buf.GetLine(position+1);
          buf.DelLine(position+1);
        end
      else led.del
    end;

#+end_src
