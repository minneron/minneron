#+title: procedural view (current procedure/method definitions)
#+tags: pr min
#+date: <2013-01-11 11:07AM>

* CLASS Editor                                                           :ed:
:PROPERTIES:
:TS: <2013-01-11 08:46AM>
:ID: sghf0g70kzf0
:END:
** constructor
:PROPERTIES:
:TS: <2013-01-12 07:37AM>
:ID: 7hd3ldk0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  constructor editor.create;
    begin
      inherited;
      x := 0;
      y := 0;
      w := kvm.width;
      h := kvm.height;
      self.buf := buffer.create;
      topline := self.buf.make_cursor;
      position := self.buf.make_cursor;
      filename := '';
      message  := 'welcome to minneron.';
    end;
#+end_src

** «tokenizer» interface
:PROPERTIES:
:TS: <2013-01-11 05:05AM>
:ID: er586tb1jzf0
:END:
#+name: @imp:ed
#+begin_src pascal

  function editor.wrap( s : string ) : li.strnode;
    begin
      result := li.strnode.create( s )
    end;

  procedure editor.parse( var txt : text );
    var n : cardinal; line : string; words : nodelist;
    begin
      while not eof( txt ) do begin
        readln( txt, line );
        self.buf.append( li.strnode.create( line ));
{
        words := nodelist.create;
        if length( line ) > 0 then
          for n := 1 to stri.nwords( line ) do begin
            log.debug([ 'word ', n, ' : ', stri.wordn( line, n ) ]);
            words.append( wrap( stri.wordn( line, n )));
          end;
        self.buf.append( li.lisnode.create( words ));
        log.debug([ 'words: ', n, ' line: "' + line + '" length: ', length( line ) ]);
}
      end;
      // li.print( lisnode.create( self.buf ));
    end;
#+end_src

** disk interface
:PROPERTIES:
:TS: <2013-01-12 07:38AM>
:ID: f41aqek0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  function editor.Load( path : string ) : boolean;
      var txt : text;
    begin
      result := fs.exists( path );
      if result then
        begin
          //  need to check for io errors in here
          assign( txt, path );
          reset( txt );
          self.parse( txt );
          close( txt );
          self.filename := path;
        end
      else message := 'couldn''t load "' + path + '"';
    end; { editor.load }

  procedure editor.NewBuffer;
      begin
        self.buf := buffer.Create;
      end;

  function editor.save : boolean;
      var txt: text; node : li.node;
    begin
      assign( txt, self.filename );
      rewrite( txt );
      for node in self.buf do begin
        if node.kind = KSTR then writeln( txt, (node as strnode).str );
      end;
      close( txt );
      result := true; // TODO error checking
      message := filename + ' saved.';
    end;

  function editor.save_as( path : string ) : boolean;
      var oldname : string;
    begin
      oldname := self.filename;
      self.filename := path;
      result := self.save;
      if not result then self.filename := oldname
    end;

#+end_src

** display
:PROPERTIES:
:TS: <2013-01-12 07:39AM>
:ID: 1oyksgk0lzf0
:END:
*** editor.show
:PROPERTIES:
:TS: <2013-01-13 04:33AM>
:ID: l0l8ixr0mzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  procedure editor.show;
    var
      ypos : cardinal;
      cur  : buffer.cursor;
      <<ed/show/curpos>>
      <<ed/show/gutter>>
      <<ed/show/edit>>
      <<ed/show/node>>
    begin
      <<ed/show:main>>
    end;
#+end_src
**** «ed/show/curpos»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: j4k6vzr0mzf0
:END:
#+name: ed/show/curpos
#+begin_src pascal
  procedure show_curpos;
  begin
    cwritexy( 0, 0,
              '|!b' +
              '|B[|C' + flushrt( n2s( self.position.index ), 6, '.' ) +
              '|w/|c' + flushrt( n2s( self.buf.length ), 6, '.' ) +
              '|B]|Y ' + self.message +
           '|%' );
    self.message := '';
  end;
#+end_src
**** «ed/show/gutter»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: dfe840s0mzf0
:END:
#+name: ed/show/gutter
#+begin_src pascal
  procedure show_gutter( s : string );
    var color : char = 'c';
  begin
    if cur.index = position.index then color := 'C';
    cwritexy( 0, ypos, '|k|!' + color + s + '|!k|w' );
  end;
#+end_src
**** «ed/show/edit»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: de5ca0s0mzf0
:END:
#+name: ed/show/edit
#+begin_src pascal
  procedure show_edit;
  begin
    { This simply positions the input widget. }
    with self.led do begin
      x := cw.cur.x;
      y := cw.cur.y;
      tcol := $080f;
      dlen := cw.max.x - cw.cur.x
    end;
    // debug: clear to eol w/blue bg to show where control should be
    // cwrite( '|!b|%' +  line + '|!k' );
    led.show;
  end;
#+end_src
**** «ed/show/node» { lines as lists implementation }
:PROPERTIES:
:TS: <2013-01-13 04:48AM>
:ID: 51l0hns0mzf0
:END:
#+name: ed/show/node
#+begin_src pascal
  procedure show_node;
  var
    tok  : string;
    d2re : cardinal; { distance to right edge }
    node : li.node;

  begin
    show_gutter( flushrt( n2s( cur.index ), 3, ' ' ));
    if cur.index = position.index then show_edit
    else if cur.value is li.strnode then
      with cur.value as li.strnode do begin
        cwrite(str)
      end
    else if cur.value is li.lisnode then
      for node in (cur.value as li.lisnode).lis do
        begin
          d2re := cw.scr.w - cw.cur.x;
          if node is li.strnode
            then tok := (node as li.strnode).str
            else tok := '|r<??>|w';
          tok += '|b.|w'; //  b/c tokenizer strips ws
          {-- word wrapping --}
          if length( tok ) < d2re then cwrite( tok )
          else begin
            cwrite( '|%' ); // clreol
            inc( ypos );
            show_gutter( '   ' );
            { truncate, in case token is wider than the whole editor }
            cwrite( stri.trunc( tok, d2re ));
          end
        end;
    inc( ypos )
  end;
#+end_src

**** «ed/show:main»
:PROPERTIES:
:TS: <2013-01-13 04:40AM>
:ID: 9u9baas0mzf0
:END:
#+name: ed/show:main
#+begin_src pascal
    begin
      cwrite('|w|!b|$'); // clrscr
  //todo  fillbox( 1, 1, kvm.maxX, kvm.maxY, $0F20 );
      show_curpos;
      ypos := 1; // line 0 is for the status / cursor position

      cur := self.buf.make_cursor;
      cur.move_to( self.topline );
      repeat
        show_node;
        cur.move_next
      until ( ypos >= self.h ) or ( cur.at_clasp );
      { fill in extra space if the file is too short }
      while ypos < self.h do begin
        cwritexy( 0, ypos, '|!K|%' );
        inc( ypos )
      end;
      cur.free;
    end;
#+end_src
*** the 'camera'
:PROPERTIES:
:TS: <2013-01-17 07:42AM>
:ID: 34mdyie1rzf0
:END:
**** «updateCamera»
:PROPERTIES:
:TS: <2013-01-17 07:42AM>
:ID: 3j1bdje1rzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  procedure editor.updatecamera;
    var screenline : word;
    begin
      assert(self.topline.index <= self.position.index );
      screenline := self.position.index - self.topline.index;
      if ( screenline < 5 ) and ( self.topline.index > 1 ) then
        begin
          self.topline.move_prev;
          //  scrolldown1(1,80,y1,y2,nil);
          //  scrolldown1(1,80,14,25,nil);
        end
      else if ( screenline > self.h - 5 )
        and ( self.topline.index < self.buf.length ) then
        begin
          self.topline.move_next;
          //  scrollup1(1,80,y1,y2,nil);
          //  scrollup1(1,80,14,25,nil);
        end
    end;
#+end_src

** cursor movement interface
:PROPERTIES:
:TS: <2013-01-12 07:41AM>
:ID: 34ca2jk0lzf0
:END:
*** home/end
:PROPERTIES:
:TS: <2013-01-17 07:32AM>
:ID: spi8g1e1rzf0
:END:

#+name: @imp:ed
#+begin_src pascal

  procedure editor.home;
  begin
    if self.buf.first = nil then exit;
    position.to_top;
    topline.to_top;
    if position.value.inheritsfrom( li.strnode ) then
      led.work := li.strnode( position.value ).str
    else
      led.work := '<<marker>>';
  end;

  procedure editor._end;
    var i : byte;
  begin
    self.position.to_end;
    self.topline.to_end;
    for i := kvm.maxY div 2 downto 1 do
      self.topline.move_prev;
  end;
#+end_src

*** up/down motion
:PROPERTIES:
:TS: <2013-01-17 07:31AM>
:ID: t7d7f0e1rzf0
:END:
#+name: @imp:ed
#+begin_src pascal

  procedure editor.grabLine;
    function to_string : string;
      var first : boolean = true; var this, node : li.node;
      begin
        result := '';
        this := self.position.value;
        case this.kind of
          KSTR :
             result := (this as li.strnode).str;
          KLIS :
            for node in (this as li.lisnode).lis do
              begin
                if first then first := false
                else result += ' ';
                result += (node as li.strnode).str;
              end
          else pass
        end
      end;
    begin
      self.led.work := to_string
    end;

  procedure editor.arrowup;
    begin
      keepInput;
      if self.position.move_prev then moveInput
      else self.position.move_next; // bounce back when hitting top
      grabLine;
    end;

  procedure editor.arrowdown;
    begin
      keepInput;
      if self.position.move_next then moveInput
      else self.position.move_prev; // bounce when hitting bottom
      grabLine;
    end;

  procedure editor.pageup;
    var c : byte;
    begin
      for c := 1 to h do arrowup;
    end;

  procedure editor.pagedown;
    var c : byte;
    begin
      for c := 1 to h do arrowdown;
    end;

#+end_src

** TODO managing the zinput control
:PROPERTIES:
:TS: <2013-01-17 07:50AM>
:ID: qcp4cc00szf0
:END:
#+name: @imp:ed
#+begin_src pascal
   procedure editor.keepInput;
   begin
     // update the edited token
     if self.position.value is strnode then
     with self.position.value as strnode do str := led.value
     else begin
       message := '|!k|R|%cursor is looking at a: ' +
                  self.position.value.classname;
     end
   end;
#+end_src

#+name: @imp:ed
#+begin_src pascal
  procedure editor.moveInput;
  begin
    updateCamera;
  end;
#+end_src

** modal interface
:PROPERTIES:
:TS: <2013-01-12 07:41AM>
:ID: lxfhwjk0lzf0
:END:

#+name: @imp:ed
#+begin_src pascal
  procedure editor.run;
    var done : boolean = false; ch : char;
    begin
      xpc.log.debug([ 'about to enter create' ]);
      self.led := ui.zinput.create;
      xpc.log.debug([ 'about to go home' ]);
      self.home;
      xpc.log.debug([ 'about to enter loop' ]);
      repeat
        show;
        case kbd.readkey(ch) of
          ^C : done := true;
          ^N : arrowdown;
          ^P : arrowup;
          ^M : newline;
          ^D : delete;
          ^S : save;
          ^V : pagedown;
          ^U : pageup;
          ^E : _end;
          #0 : case kbd.readkey(ch) of
                      #72 : arrowup; // when you press the UP arrow!
                      #80 : arrowdown; // when you press the DOWN arrow!
                      #71 : home;
                      #79 : _end;
                      #73 : pageup;
                      #81 : pagedown;
                      ^M  : newline;
                      else led.handlestripped( ch ); led.show;
                    end;
          else led.handle( ch ); led.show;
        end;
        led.isdone := false; // TODO: split lines on ^M/^J
      until done;
    end;
#+end_src

** multi-line editor commands
:PROPERTIES:
:TS: <2013-01-12 07:42AM>
:ID: pn7bmlk0lzf0
:END:

#+name: @imp:ed
#+begin_src pascal
  procedure editor.newline;
    begin
      position.inject_next( strnode.create( led.str_to_end ));
      led.del_to_end;
      arrowdown;
      led.to_start;
    end; { editor.newline }

  procedure editor.delete;
    var cur : buffer.cursor;
    begin
      if led.at_end then begin
        if not position.at_end then begin
          cur := buf.make_cursor;
          cur.move_to(position);
          cur.move_next;
          led.work += li.strnode( cur.value ).str;
          position.delete_next;
          cur.free;
        end
      end else led.del
    end;
#+end_src
