#+title: procedural view (current procedure/method definitions)
#+tags: pr min
#+date: <2013-01-11 11:07AM>

* CLASS Editor                                                           :ed:
:PROPERTIES:
:TS: <2013-01-11 08:46AM>
:ID: sghf0g70kzf0
:END:
** constructor
:PROPERTIES:
:TS: <2013-01-12 07:37AM>
:ID: 7hd3ldk0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  constructor editor.create;
  begin
    inherited;
    x := 1;
    y := 1;
    w := crt.windMaxX;
    h := crt.windMaxY;
    self.buf := buffer.create;
    topline := self.buf.make_cursor;
    position := self.buf.make_cursor;
    filename := '';
    message  := 'welcome to minneron.';
  end;
#+end_src

** «tokenizer» interface
:PROPERTIES:
:TS: <2013-01-11 05:05AM>
:ID: er586tb1jzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  procedure editor.parse( var txt : text ); 
  var n : cardinal; line : string; words : li.nodelist;
  begin
    while not eof( txt ) do begin
      readln( txt, line );
      words :=  li.nodelist.create;
      if length( line ) > 0 then
        for n := 1 to stri.nwords( line ) do begin
          writeln( 'word ', n, ' : ', stri.wordn( line, n ));
          words.append( li.strnode.create( stri.wordn( line, n )));
        end;
      self.buf.append( li.lisnode.create( words ));
      writeln( 'n: ', n, ' line: "' + line + '" length: ', + length( line ));
    end;
    li.print( lisnode.create( self.buf ));
  end;
#+end_src

** disk interface
:PROPERTIES:
:TS: <2013-01-12 07:38AM>
:ID: f41aqek0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  function editor.load( path : string ) : boolean;
    var txt : text; line : string;
  begin
    result := fs.exists( path );
    if result then begin
      //  need to check for io errors in here
      assign( txt, path );
      reset( txt );
      self.parse( txt );
      close( txt );
      self.filename := path;
    end;
  end; { editor.load }

  function editor.save : boolean;
    var txt: text; node : li.node;
  begin
    assign( txt, self.filename );
    rewrite( txt );
    for node in self.buf do begin
      if node.kind = KSTR then writeln( txt, (node as strnode).str );
    end;
    close( txt );
    result := true; // TODO error checking
    message := filename + ' saved.';
  end;

  function editor.save_as( path : string ) : boolean;
    var oldname : string;
  begin
    oldname := self.filename;
    self.filename := path;
    result := self.save;
    if not result then self.filename := oldname
  end;
#+end_src

** display interface
:PROPERTIES:
:TS: <2013-01-12 07:39AM>
:ID: 1oyksgk0lzf0
:END:
*** editor.show
:PROPERTIES:
:TS: <2013-01-13 04:33AM>
:ID: l0l8ixr0mzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  procedure editor.show;
    var
      ypos : cardinal;
      cur  : buffer.cursor;
      line : string = '';
    <<ed/show/curpos>>
    <<ed/show/nums>>
    <<ed/show/edit>>
    <<ed/show/node>>
  begin
    <<ed/show:main>>
  end;
#+end_src
*** «ed/show/curpos»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: j4k6vzr0mzf0
:END:
#+name: ed/show/curpos
#+begin_src pascal
  procedure show_curpos;
  begin
    cwritexy( 1, 1,
              '|B[|C' + flushrt( n2s( self.position.index ), 6, '.' ) +
              '|w/|c' + flushrt( n2s( self.buf.count ), 6, '.' ) +
              '|B] |G' + self.message +
           '|%' );
    self.message := '';
  end;
#+end_src
*** «ed/show/nums»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: dfe840s0mzf0
:END:
#+name: ed/show/nums
#+begin_src pascal
  procedure show_nums( wrap : boolean = false );
  var s : string;
  begin
    cwritexy( 1, ypos, '|k|!c' );
    if wrap then s := '|C...' else s := n2s( cur.index );
    cwrite( flushrt( s, 3, ' ' ));
    cwrite( '|!k|w' );
  end;
#+end_src
*** «ed/show/edit»
:PROPERTIES:
:TS: <2013-01-13 04:34AM>
:ID: de5ca0s0mzf0
:END:
#+name: ed/show/edit
#+begin_src pascal
  procedure show_edit( line : string );
  begin
    { This simply positions the input widget. }
    with self.led do begin
      x := crt.wherex;
      y := crt.wherey;
      tcol := $0E; // bright yellow
      dlen := crt.windmaxx - crt.wherex;
    end;
    // debug: clear to eol w/blue bg to show where control should be
    // cwrite( '|!b|%' );
    led.show;
  end;
#+end_src
*** «ed/show/node» { lines as lists implementation }
:PROPERTIES:
:TS: <2013-01-13 04:48AM>
:ID: 51l0hns0mzf0
:END:
#+name: ed/show/node
#+begin_src pascal
  procedure show_node;
  var
    tok  : string;
    tcur : li.nodelist.cursor;
    d2re : cardinal; { distance to right edge }
    node : li.node;
  begin
    show_nums;
    for node in (cur.value as li.lisnode).lis do
    begin
      d2re := cw.scr.w - cw.cur.x;
      tok := (node as li.strnode).str + '|K.|w'; //  because tokenizer strips ws :(
      {-- word wrapping --}
      if length( tok ) < d2re then cwrite( tok )
      else begin
        cwrite( '|%' ); // clreol
        inc( ypos );
        show_nums( false );
        { truncate, just in case token is wider than the whole editor }
        cwrite( stri.trunc( tok, d2re ));
      end
    end;
    inc( ypos ) { set up for the next block }
  end;
#+end_src

*** «ed/show:main»
:PROPERTIES:
:TS: <2013-01-13 04:40AM>
:ID: 9u9baas0mzf0
:END:
#+name: ed/show:main
#+begin_src pascal
  begin
    clrscr; //  fillbox( 1, 1, crt.windmaxx, crt.windmaxy, $0F20 );
    show_curpos;
    ypos := 2;
  
    cur := self.buf.make_cursor;
    cur.move_to( self.topline );
  
    repeat show_node; cur.move_next
    until ( ypos >= self.h ) or ( cur.at_end );
    
    while ypos < self.h do begin
      cwritexy( 1, ypos, '|%' );
      inc( ypos )
    end;
    // led.show
  end;
#+end_src
** cursor movement interface
:PROPERTIES:
:TS: <2013-01-12 07:41AM>
:ID: 34ca2jk0lzf0
:END:
#+name: @imp:ed
#+begin_src pascal
  
  procedure editor.home;
  begin
    if self.buf.first = nil then exit;
    position.to_top;
    topline.to_top;
    if position.value.inheritsfrom( li.strnode ) then
      led.work := li.strnode( position.value ).str
    else
      led.work := '<<marker>>';
  end;
  
  procedure editor._end;
    var i : byte;
  begin
    self.position.to_end;
    self.topline.to_end;
    for i := crt.windmaxy div 2 downto 1 do
      self.topline.move_prev;
  end;
  
  procedure editor.pageup;
    var c : byte;
  begin for c := 1 to h do arrowup;
  end;
  
  procedure editor.pagedown;
    var c : byte;
  begin for c := 1 to h do arrowdown;
  end; { editor.pagedown }
#+end_src

#+name: @imp:ed
#+begin_src pascal
  procedure editor.arrowup;
  begin
    li.strnode(self.position.value).str := led.value;
    if self.position.move_prev then
    begin
      if self.position.index - self.topline.index < 5 then
          if self.topline.index > 1 then
             self.topline.move_prev;
      //  scrolldown1(1,80,y1,y2,nil);
      //  scrolldown1(1,80,14,25,nil);
    end
    else self.position.move_next;
    led.work := li.strnode(self.position.value).str;
  end;

  procedure editor.arrowdown;
    var screenline : word;
  begin
    li.strnode(self.position.value).str := led.value;
    if self.position.move_next then
      begin
        assert( self.topline.index <= self.position.index );
        screenline := self.position.index - self.topline.index;
        if ( screenline > self.h - 5 ) and ( self.topline.index < self.buf.count ) then
           self.topline.move_next
          //  scrollup1(1,80,y1,y2,nil);
          //  scrollup1(1,80,14,25,nil);
      end
    else self.position.to_end;
    led.work := li.strnode(self.position.value).str;
  end;
#+end_src

** modal interface
:PROPERTIES:
:TS: <2013-01-12 07:41AM>
:ID: lxfhwjk0lzf0
:END:

#+name: @imp:ed
#+begin_src pascal
  procedure editor.run;
    var done : boolean = false; ch : char;
  begin
    xpc.log.debug([ 'about to enter create' ]);
    self.led := ui.zinput.create;
    xpc.log.debug([ 'about to go home' ]);
    self.home;
    xpc.log.debug([ 'about to enter loop' ]);
    repeat
      show;
      case kbd.readkey(ch) of
        ^C : done := true;
        ^N : arrowdown;
        ^P : arrowup;
        ^M : newline;
        ^D : delete;
        ^S : save;
        ^V : pagedown;
        ^U : pageup;
        #0 : case kbd.readkey(ch) of
                    #72 : arrowup; // when you press the UP arrow!
                    #80 : arrowdown; // when you press the DOWN arrow!
                    #71 : home;
                    #79 : _end;
                    #73 : pageup;
                    #81 : pagedown;
                    else led.handlestripped( ch ); led.show;
                  end;
        else led.handle( ch ); led.show;
      end
    until done;
  end;
#+end_src

** multi-line editor commands
:PROPERTIES:
:TS: <2013-01-12 07:42AM>
:ID: pn7bmlk0lzf0
:END:

#+name: @imp:ed
#+begin_src pascal
  procedure editor.newline;
  begin
    position.inject_next( strnode.create( led.str_to_end ));
    led.del_to_end;
    arrowdown;
    led.to_start
  end; { editor.newline }

  procedure editor.delete;
    var cur : buffer.cursor;
  begin
    if led.at_end then begin
      if not position.at_end then begin
        cur := buf.make_cursor;
        cur.move_to(position);
        cur.move_next;
        led.work += li.strnode( cur.value ).str;
        position.delete_next;
        cur.free;
      end
    end
    else led.del
  end;
#+end_src
