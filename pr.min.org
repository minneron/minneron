#+title: procedural view (current procedure/method definitions)
#+tags: pr min
#+date: <2013-01-11 11:07AM>

* CLASS TEditor                                                 :ed:
:PROPERTIES:
:TS: <2013-01-11 08:46AM>
:ID: sghf0g70kzf0
:END:
** TODO «tokenizer» interface { extract tokenizer stuff }
:PROPERTIES:
:TS: <2013-01-11 05:05AM>
:ID: er586tb1jzf0
:END:
#+name: @imp:ed
#+begin_src pascal

        words := nodelist.create;
        if length( line ) > 0 then
          for n := 1 to stri.nwords( line ) do begin
            log.debug([ 'word ', n, ' : ', stri.wordn( line, n ) ]);
            words.append( wrap( stri.wordn( line, n )));
          end;
        self.buf.append( li.lisnode.create( words ));
        log.debug([ 'words: ', n, ' line: "' + line + '" length: ', length( line ) ]);


#+end_src

** TODO «ed/draw/node» { move =draw_node= logic to =TOutline= }
:PROPERTIES:
:TS: <2013-01-13 04:48AM>
:ID: 51l0hns0mzf0
:END:
#+name: draw_node
#+begin_src pascal

  procedure draw_list(node:li.lisnode);
    var
      tok   : string;
      d2re  : cardinal; { distance to right edge }
      child : li.node;
    begin
      for child in node.lis do
        begin
          d2re := cw.scr.w - cw.cur.x;
          if child is li.strnode
            then tok := (child as li.strnode).str
            else tok := '|r<??>|w';
          tok += '|b.|w'; //  b/c tokenizer strips ws
          {-- word wrapping --}
          if length( tok ) < d2re then cwrite( tok )
          else begin
            cwrite( '|!k|%' ); // clreol
            inc( ypos );
            draw_gutter( '   ' );
            { truncate, in case token is wider than the whole editor }
            cwrite( stri.trunc( tok, d2re ));
          end
        end;
    end;

#+end_src

** TODO move this old =TEditor.grabline= code to =TOutline=
:PROPERTIES:
:TS:       <2013-10-01 05:49PM>
:ID:       f8y9o3g079g0
:END:

#+begin_src pascal
    function to_string : string;
      var first : boolean = true; var this, node : li.node;
      begin
        result := '';
        this := self.position.value;
        case this.kind of
          KSTR :
             result := (this as li.strnode).str;
          KLIS :
            for node in (this as li.lisnode).lis do
              begin
                if first then first := false
                else result += ' ';
                result += (node as li.strnode).str;
              end
          else pass
        end
      end;
#+end_src
